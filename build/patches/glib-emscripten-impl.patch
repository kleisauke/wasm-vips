From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 24 Aug 2022 21:55:32 +0200
Subject: [PATCH 6/7] Add support for WebAssembly

- Exclude unix specific files.
- Add Wasm-specific platform definition.
- Use `.wasm` as shared module suffix.
- Disable subprocess, spawn, signal, pipe, and stdin usage.
- Implement `g_get_os_info(G_OS_INFO_KEY_NAME)`.
- Implement `g_time_zone_new_identifier(NULL)`.
- Implement `g_get_num_processors()`.

Upstream-Status: Pending

diff --git a/gio/gappinfo.c b/gio/gappinfo.c
index 1111111..2222222 100644
--- a/gio/gappinfo.c
+++ b/gio/gappinfo.c
@@ -1014,7 +1014,7 @@ g_app_info_launch_default_for_uri (const char         *uri,
       g_object_unref (app_info);
     }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   if (!res && glib_should_use_portal ())
     {
       const char *parent_window = NULL;
@@ -1066,7 +1066,7 @@ launch_default_for_uri_portal_open_uri_cb (GObject      *object,
 static void
 launch_default_for_uri_portal_open_uri (GTask *task, GError *error)
 {
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   LaunchDefaultForUriData *data = g_task_get_task_data (task);
   GCancellable *cancellable = g_task_get_cancellable (task);
 
diff --git a/gio/gapplicationcommandline.c b/gio/gapplicationcommandline.c
index 1111111..2222222 100644
--- a/gio/gapplicationcommandline.c
+++ b/gio/gapplicationcommandline.c
@@ -297,7 +297,9 @@ g_application_command_line_real_printerr_literal (GApplicationCommandLine *cmdli
 static GInputStream *
 g_application_command_line_real_get_stdin (GApplicationCommandLine *cmdline)
 {
-#ifdef G_OS_UNIX
+#ifdef G_PLATFORM_WASM
+  return NULL;
+#elif defined(G_OS_UNIX)
   return g_unix_input_stream_new (0, FALSE);
 #else
   return g_win32_input_stream_new (GetStdHandle (STD_INPUT_HANDLE), FALSE);
diff --git a/gio/gdesktopappinfo.c b/gio/gdesktopappinfo.c
index 1111111..2222222 100644
--- a/gio/gdesktopappinfo.c
+++ b/gio/gdesktopappinfo.c
@@ -42,7 +42,7 @@
 
 #include "gcontenttypeprivate.h"
 #include "gdesktopappinfo.h"
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "glib-unix.h"
 #endif
 #include "gfile.h"
@@ -57,7 +57,7 @@
 #include "gappinfoprivate.h"
 #include "glocalfilemonitor.h"
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "gdocumentportal.h"
 #endif
 
@@ -3178,7 +3178,7 @@ g_desktop_app_info_launch_uris_with_dbus (GDesktopAppInfo    *info,
 
   g_return_val_if_fail (info != NULL, FALSE);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   app_id = g_desktop_app_info_get_string (info, "X-Flatpak");
   if (app_id && *app_id)
     {
diff --git a/gio/gfile.c b/gio/gfile.c
index 1111111..2222222 100644
--- a/gio/gfile.c
+++ b/gio/gfile.c
@@ -58,7 +58,7 @@
 
 #include "gfile.h"
 #include "glib/gstdio.h"
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "glib-unix.h"
 #endif
 #include "gvfs.h"
diff --git a/gio/gkeyfilesettingsbackend.c b/gio/gkeyfilesettingsbackend.c
index 1111111..2222222 100644
--- a/gio/gkeyfilesettingsbackend.c
+++ b/gio/gkeyfilesettingsbackend.c
@@ -79,7 +79,7 @@ typedef struct
   GFileMonitor      *dir_monitor;
 } GKeyfileSettingsBackend;
 
-#ifdef G_OS_WIN32
+#if defined(G_OS_WIN32) || defined(G_PLATFORM_WASM)
 #define EXTENSION_PRIORITY 10
 #else
 #define EXTENSION_PRIORITY (glib_should_use_portal () && !glib_has_dconf_access_in_sandbox () ? 110 : 10)
diff --git a/gio/glocalfile.c b/gio/glocalfile.c
index 1111111..2222222 100644
--- a/gio/glocalfile.c
+++ b/gio/glocalfile.c
@@ -27,7 +27,7 @@
 #include <string.h>
 #include <errno.h>
 #include <fcntl.h>
-#if G_OS_UNIX
+#ifdef G_OS_UNIX
 #include <dirent.h>
 #include <unistd.h>
 #endif
@@ -65,7 +65,7 @@
 #include <glib/gstdio.h>
 #include <glib/gstdioprivate.h>
 #include "glibintl.h"
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "glib-unix.h"
 #include "gportalsupport.h"
 #include "gtrashportal.h"
@@ -1921,7 +1921,7 @@ _g_local_file_has_trash_dir (const char *dirname, dev_t dir_dev)
   return res;
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 gboolean
 _g_local_file_is_lost_found_dir (const char *path, dev_t path_dev)
 {
@@ -1985,8 +1985,10 @@ g_local_file_trash (GFile         *file,
   GVfs *vfs;
   int errsv;
 
+#ifndef G_PLATFORM_WASM
   if (glib_should_use_portal ())
     return g_trash_portal_trash_file (file, error);
+#endif
 
   if (g_lstat (local->filename, &file_stat) != 0)
     {
diff --git a/gio/glocalfileinfo.c b/gio/glocalfileinfo.c
index 1111111..2222222 100644
--- a/gio/glocalfileinfo.c
+++ b/gio/glocalfileinfo.c
@@ -62,8 +62,10 @@
 
 #ifdef G_OS_UNIX
 #include <unistd.h>
+#ifndef G_PLATFORM_WASM
 #include "glib-unix.h"
-#endif
+#endif /*!G_PLATFORM_WASM*/
+#endif /*G_OS_UNIX*/
 
 #include "glib-private.h"
 
@@ -1947,7 +1949,7 @@ _g_local_file_info_get (const char             *basename,
   if (stat_ok)
     set_info_from_stat (info, &statbuf, attribute_matcher);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   if (stat_ok && _g_local_file_is_lost_found_dir (path, _g_stat_dev (&statbuf)))
     g_file_info_set_is_hidden (info, TRUE);
 #endif
diff --git a/gio/glocalfileinputstream.c b/gio/glocalfileinputstream.c
index 1111111..2222222 100644
--- a/gio/glocalfileinputstream.c
+++ b/gio/glocalfileinputstream.c
@@ -37,9 +37,11 @@
 
 #ifdef G_OS_UNIX
 #include <unistd.h>
+#ifndef G_PLATFORM_WASM
 #include "glib-unix.h"
 #include "gfiledescriptorbased.h"
-#endif
+#endif /*!G_PLATFORM_WASM*/
+#endif /*G_OS_UNIX*/
 
 #ifdef G_OS_WIN32
 #include <io.h>
@@ -50,12 +52,12 @@ struct _GLocalFileInputStreamPrivate {
   guint do_close : 1;
 };
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void       g_file_descriptor_based_iface_init   (GFileDescriptorBasedIface *iface);
 #endif
 
 #define g_local_file_input_stream_get_type _g_local_file_input_stream_get_type
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 G_DEFINE_TYPE_WITH_CODE (GLocalFileInputStream, g_local_file_input_stream, G_TYPE_FILE_INPUT_STREAM,
                          G_ADD_PRIVATE (GLocalFileInputStream)
 			 G_IMPLEMENT_INTERFACE (G_TYPE_FILE_DESCRIPTOR_BASED,
@@ -84,7 +86,7 @@ static GFileInfo *g_local_file_input_stream_query_info (GFileInputStream  *strea
 							const char        *attributes,
 							GCancellable      *cancellable,
 							GError           **error);
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static int        g_local_file_input_stream_get_fd     (GFileDescriptorBased *stream);
 #endif
 
@@ -109,7 +111,7 @@ g_local_file_input_stream_class_init (GLocalFileInputStreamClass *klass)
   file_stream_class->query_info = g_local_file_input_stream_query_info;
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void
 g_file_descriptor_based_iface_init (GFileDescriptorBasedIface *iface)
 {
@@ -297,7 +299,7 @@ g_local_file_input_stream_query_info (GFileInputStream  *stream,
 					 error);
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static int
 g_local_file_input_stream_get_fd (GFileDescriptorBased *fd_based)
 {
diff --git a/gio/glocalfileoutputstream.c b/gio/glocalfileoutputstream.c
index 1111111..2222222 100644
--- a/gio/glocalfileoutputstream.c
+++ b/gio/glocalfileoutputstream.c
@@ -44,9 +44,11 @@
 
 #ifdef G_OS_UNIX
 #include <unistd.h>
+#ifndef G_PLATFORM_WASM
 #include "gfiledescriptorbased.h"
 #include <sys/uio.h>
-#endif
+#endif /*!G_PLATFORM_WASM*/
+#endif /*G_OS_UNIX*/
 
 #include "glib-private.h"
 #include "gioprivate.h"
@@ -81,12 +83,12 @@ struct _GLocalFileOutputStreamPrivate {
   int fd;
 };
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void       g_file_descriptor_based_iface_init   (GFileDescriptorBasedIface *iface);
 #endif
 
 #define g_local_file_output_stream_get_type _g_local_file_output_stream_get_type
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 G_DEFINE_TYPE_WITH_CODE (GLocalFileOutputStream, g_local_file_output_stream, G_TYPE_FILE_OUTPUT_STREAM,
                          G_ADD_PRIVATE (GLocalFileOutputStream)
 			 G_IMPLEMENT_INTERFACE (G_TYPE_FILE_DESCRIPTOR_BASED,
@@ -108,7 +110,7 @@ static gssize     g_local_file_output_stream_write        (GOutputStream      *s
 							   gsize               count,
 							   GCancellable       *cancellable,
 							   GError            **error);
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static gboolean   g_local_file_output_stream_writev       (GOutputStream       *stream,
 							   const GOutputVector *vectors,
 							   gsize                n_vectors,
@@ -136,7 +138,7 @@ static gboolean   g_local_file_output_stream_truncate     (GFileOutputStream  *s
 							   goffset             size,
 							   GCancellable       *cancellable,
 							   GError            **error);
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static int        g_local_file_output_stream_get_fd       (GFileDescriptorBased *stream);
 #endif
 
@@ -165,7 +167,7 @@ g_local_file_output_stream_class_init (GLocalFileOutputStreamClass *klass)
   gobject_class->finalize = g_local_file_output_stream_finalize;
 
   stream_class->write_fn = g_local_file_output_stream_write;
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   stream_class->writev_fn = g_local_file_output_stream_writev;
 #endif
   stream_class->close_fn = g_local_file_output_stream_close;
@@ -178,7 +180,7 @@ g_local_file_output_stream_class_init (GLocalFileOutputStreamClass *klass)
   file_stream_class->truncate_fn = g_local_file_output_stream_truncate;
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void
 g_file_descriptor_based_iface_init (GFileDescriptorBasedIface *iface)
 {
@@ -234,7 +236,7 @@ g_local_file_output_stream_write (GOutputStream  *stream,
  * things, that each chunk is the size of a whole page and in memory aligned
  * to a page. We can't possibly guarantee that in GLib.
  */
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 /* Macro to check if struct iovec and GOutputVector have the same ABI */
 #define G_OUTPUT_VECTOR_IS_IOVEC (sizeof (struct iovec) == sizeof (GOutputVector) && \
       G_SIZEOF_MEMBER (struct iovec, iov_base) == G_SIZEOF_MEMBER (GOutputVector, buffer) && \
@@ -1332,7 +1334,7 @@ _g_local_file_output_stream_get_fd (GLocalFileOutputStream *stream)
   return stream->priv->fd;
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static int
 g_local_file_output_stream_get_fd (GFileDescriptorBased *fd_based)
 {
diff --git a/gio/glocalvfs.c b/gio/glocalvfs.c
index 1111111..2222222 100644
--- a/gio/glocalvfs.c
+++ b/gio/glocalvfs.c
@@ -28,7 +28,7 @@
 #include "gvfs.h"
 #include <gio/gdummyfile.h>
 #include <sys/types.h>
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "glib-unix.h"
 #include <pwd.h>
 #endif
@@ -147,7 +147,7 @@ g_local_vfs_parse_name (GVfs       *vfs,
     {
       if (*parse_name == '~')
 	{
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 	  const char *user_start;
 	  user_start = parse_name + 1;
 #endif
@@ -158,7 +158,7 @@ g_local_vfs_parse_name (GVfs       *vfs,
 	  
 	  user_end = parse_name;
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 	  if (user_end == user_start)
 	    user_prefix = g_strdup (g_get_home_dir ());
 	  else
diff --git a/gio/gportalsupport.c b/gio/gportalsupport.c
index 1111111..2222222 100644
--- a/gio/gportalsupport.c
+++ b/gio/gportalsupport.c
@@ -26,6 +26,7 @@ static gboolean use_portal;
 static gboolean network_available;
 static gboolean dconf_access;
 
+#ifndef G_PLATFORM_WASM
 static void
 read_flatpak_info (void)
 {
@@ -80,24 +81,37 @@ read_flatpak_info (void)
 
   g_once_init_leave (&flatpak_info_read, 1);
 }
+#endif
 
 gboolean
 glib_should_use_portal (void)
 {
+#ifdef G_PLATFORM_WASM
+  return FALSE;
+#else
   read_flatpak_info ();
   return use_portal;
+#endif
 }
 
 gboolean
 glib_network_available_in_sandbox (void)
 {
+#ifdef G_PLATFORM_WASM
+  return FALSE;
+#else
   read_flatpak_info ();
   return network_available;
+#endif
 }
 
 gboolean
 glib_has_dconf_access_in_sandbox (void)
 {
+#ifdef G_PLATFORM_WASM
+  return FALSE;
+#else
   read_flatpak_info ();
   return dconf_access;
+#endif
 }
diff --git a/gio/gsocket.c b/gio/gsocket.c
index 1111111..2222222 100644
--- a/gio/gsocket.c
+++ b/gio/gsocket.c
@@ -31,7 +31,7 @@
 
 #include "gsocket.h"
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "glib-unix.h"
 #endif
 
@@ -54,7 +54,7 @@
 # include <sys/filio.h>
 #endif
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include <sys/uio.h>
 #endif
 
@@ -708,9 +708,9 @@ g_socket_constructed (GObject *object)
 
   if (socket->priv->fd != -1)
     {
-#ifndef G_OS_WIN32
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       GError *error = NULL;
-#else
+#elif defined(G_OS_WIN32)
       gulong arg;
 #endif
 
@@ -718,13 +718,13 @@ g_socket_constructed (GObject *object)
        * nonblocking automatically in certain operations. This way we make
        * things work the same on all platforms.
        */
-#ifndef G_OS_WIN32
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       if (!g_unix_set_fd_nonblocking (socket->priv->fd, TRUE, &error))
         {
           g_warning ("Error setting socket nonblocking: %s", error->message);
           g_clear_error (&error);
         }
-#else
+#elif defined(G_OS_WIN32)
       arg = TRUE;
 
       if (ioctlsocket (socket->priv->fd, FIONBIO, &arg) == SOCKET_ERROR)
@@ -4012,7 +4012,7 @@ socket_source_dispatch (GSource     *source,
     events = G_IO_NVAL;
   else
     events = update_condition (socket_source->socket);
-#else
+#elif defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   if (g_socket_is_closed (socket_source->socket))
     {
       if (socket_source->fd_tag)
@@ -4150,7 +4150,7 @@ socket_source_new (GSocket      *socket,
   socket_source->pollfd.events = condition;
   socket_source->pollfd.revents = 0;
   g_source_add_poll (source, &socket_source->pollfd);
-#else
+#elif defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   socket_source->fd_tag = g_source_add_unix_fd (source, socket->priv->fd, condition);
 #endif
 
diff --git a/gio/gsocketinputstream.c b/gio/gsocketinputstream.c
index 1111111..2222222 100644
--- a/gio/gsocketinputstream.c
+++ b/gio/gsocketinputstream.c
@@ -42,13 +42,13 @@ struct _GSocketInputStreamPrivate
 };
 
 static void g_socket_input_stream_pollable_iface_init (GPollableInputStreamInterface *iface);
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void g_socket_input_stream_file_descriptor_based_iface_init (GFileDescriptorBasedIface *iface);
 #endif
 
 #define g_socket_input_stream_get_type _g_socket_input_stream_get_type
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 G_DEFINE_TYPE_WITH_CODE (GSocketInputStream, g_socket_input_stream, G_TYPE_INPUT_STREAM,
                          G_ADD_PRIVATE (GSocketInputStream)
 			 G_IMPLEMENT_INTERFACE (G_TYPE_POLLABLE_INPUT_STREAM, g_socket_input_stream_pollable_iface_init)
@@ -168,7 +168,7 @@ g_socket_input_stream_pollable_read_nonblocking (GPollableInputStream  *pollable
 					 NULL, error);
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static int
 g_socket_input_stream_get_fd (GFileDescriptorBased *fd_based)
 {
@@ -198,7 +198,7 @@ g_socket_input_stream_class_init (GSocketInputStreamClass *klass)
 							G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void
 g_socket_input_stream_file_descriptor_based_iface_init (GFileDescriptorBasedIface *iface)
 {
diff --git a/gio/gsocketoutputstream.c b/gio/gsocketoutputstream.c
index 1111111..2222222 100644
--- a/gio/gsocketoutputstream.c
+++ b/gio/gsocketoutputstream.c
@@ -47,13 +47,13 @@ struct _GSocketOutputStreamPrivate
 };
 
 static void g_socket_output_stream_pollable_iface_init (GPollableOutputStreamInterface *iface);
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void g_socket_output_stream_file_descriptor_based_iface_init (GFileDescriptorBasedIface *iface);
 #endif
 
 #define g_socket_output_stream_get_type _g_socket_output_stream_get_type
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 G_DEFINE_TYPE_WITH_CODE (GSocketOutputStream, g_socket_output_stream, G_TYPE_OUTPUT_STREAM,
                          G_ADD_PRIVATE (GSocketOutputStream)
 			 G_IMPLEMENT_INTERFACE (G_TYPE_POLLABLE_OUTPUT_STREAM, g_socket_output_stream_pollable_iface_init)
@@ -223,7 +223,7 @@ g_socket_output_stream_pollable_create_source (GPollableOutputStream *pollable,
   return pollable_source;
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static int
 g_socket_output_stream_get_fd (GFileDescriptorBased *fd_based)
 {
@@ -254,7 +254,7 @@ g_socket_output_stream_class_init (GSocketOutputStreamClass *klass)
 							G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void
 g_socket_output_stream_file_descriptor_based_iface_init (GFileDescriptorBasedIface *iface)
 {
diff --git a/gio/gsubprocess.c b/gio/gsubprocess.c
index 1111111..2222222 100644
--- a/gio/gsubprocess.c
+++ b/gio/gsubprocess.c
@@ -95,7 +95,7 @@
 #include "glib-private.h"
 
 #include <string.h>
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include <gio/gunixoutputstream.h>
 #include <gio/gfiledescriptorbased.h>
 #include <gio/gunixinputstream.h>
@@ -108,6 +108,14 @@
 #include <io.h>
 #include "giowin32-priv.h"
 #endif
+#ifdef G_PLATFORM_WASM
+#include <gio/gioenumtypes.h>
+#include <gio/ginitable.h>
+#include <gio/gtask.h>
+#include <gio/gmemoryinputstream.h>
+#include <gio/gmemoryoutputstream.h>
+#include <unistd.h>
+#endif
 
 #ifndef O_BINARY
 #define O_BINARY 0
@@ -190,7 +198,9 @@ platform_input_stream_from_spawn_fd (gint fd)
   if (fd < 0)
     return NULL;
 
-#ifdef G_OS_UNIX
+#ifdef G_PLATFORM_WASM
+  return NULL;
+#elif defined(G_OS_UNIX)
   return g_unix_input_stream_new (fd, TRUE);
 #else
   return g_win32_input_stream_new_from_fd (fd, TRUE);
@@ -203,14 +213,16 @@ platform_output_stream_from_spawn_fd (gint fd)
   if (fd < 0)
     return NULL;
 
-#ifdef G_OS_UNIX
+#ifdef G_PLATFORM_WASM
+  return NULL;
+#elif defined(G_OS_UNIX)
   return g_unix_output_stream_new (fd, TRUE);
 #else
   return g_win32_output_stream_new_from_fd (fd, TRUE);
 #endif
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static gint
 unix_open_file (const char  *filename,
                 gint         mode,
@@ -304,7 +316,7 @@ initable_init (GInitable     *initable,
   gint *pipe_ptrs[3] = { NULL, NULL, NULL };
   gint pipe_fds[3] = { -1, -1, -1 };
   gint close_fds[3] = { -1, -1, -1 };
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   gint stdin_fd = -1, stdout_fd = -1, stderr_fd = -1;
 #endif
   GSpawnFlags spawn_flags = 0;
@@ -327,7 +339,7 @@ initable_init (GInitable     *initable,
     spawn_flags |= G_SPAWN_CHILD_INHERITS_STDIN;
   else if (self->flags & G_SUBPROCESS_FLAGS_STDIN_PIPE)
     pipe_ptrs[0] = &pipe_fds[0];
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   else if (self->launcher)
     {
       if (self->launcher->stdin_fd != -1)
@@ -346,7 +358,7 @@ initable_init (GInitable     *initable,
     spawn_flags |= G_SPAWN_STDOUT_TO_DEV_NULL;
   else if (self->flags & G_SUBPROCESS_FLAGS_STDOUT_PIPE)
     pipe_ptrs[1] = &pipe_fds[1];
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   else if (self->launcher)
     {
       if (self->launcher->stdout_fd != -1)
@@ -365,7 +377,7 @@ initable_init (GInitable     *initable,
     spawn_flags |= G_SPAWN_STDERR_TO_DEV_NULL;
   else if (self->flags & G_SUBPROCESS_FLAGS_STDERR_PIPE)
     pipe_ptrs[2] = &pipe_fds[2];
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   else if (self->flags & G_SUBPROCESS_FLAGS_STDERR_MERGE)
     /* This will work because stderr gets set up after stdout. */
     stderr_fd = 1;
@@ -401,7 +413,7 @@ initable_init (GInitable     *initable,
                                               (const gchar * const *) self->argv,
                                               (const gchar * const *) (self->launcher ? self->launcher->envp : NULL),
                                               spawn_flags,
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
                                               self->launcher ? self->launcher->child_setup_func : NULL,
                                               self->launcher ? self->launcher->child_setup_user_data : NULL,
                                               stdin_fd, stdout_fd, stderr_fd,
@@ -445,7 +457,7 @@ initable_init (GInitable     *initable,
       g_source_unref (source);
     }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 out:
 #endif
   /* we don't need this past init... */
@@ -950,7 +962,7 @@ g_subprocess_wait_check_finish (GSubprocess   *subprocess,
          g_spawn_check_wait_status (subprocess->status, error);
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 typedef struct
 {
   GSubprocess *subprocess;
@@ -1045,9 +1057,9 @@ g_subprocess_force_exit (GSubprocess *subprocess)
 {
   g_return_if_fail (G_IS_SUBPROCESS (subprocess));
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   g_subprocess_dispatch_signal (subprocess, SIGKILL);
-#else
+#elif defined(G_OS_WIN32)
   TerminateProcess (subprocess->pid, 1);
 #endif
 }
@@ -1102,7 +1114,7 @@ g_subprocess_get_successful (GSubprocess *subprocess)
   g_return_val_if_fail (G_IS_SUBPROCESS (subprocess), FALSE);
   g_return_val_if_fail (subprocess->pid == 0, FALSE);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   return WIFEXITED (subprocess->status) && WEXITSTATUS (subprocess->status) == 0;
 #else
   return subprocess->status == 0;
@@ -1131,7 +1143,7 @@ g_subprocess_get_if_exited (GSubprocess *subprocess)
   g_return_val_if_fail (G_IS_SUBPROCESS (subprocess), FALSE);
   g_return_val_if_fail (subprocess->pid == 0, FALSE);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   return WIFEXITED (subprocess->status);
 #else
   return TRUE;
@@ -1161,7 +1173,7 @@ g_subprocess_get_exit_status (GSubprocess *subprocess)
   g_return_val_if_fail (G_IS_SUBPROCESS (subprocess), 1);
   g_return_val_if_fail (subprocess->pid == 0, 1);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   g_return_val_if_fail (WIFEXITED (subprocess->status), 1);
 
   return WEXITSTATUS (subprocess->status);
@@ -1191,7 +1203,7 @@ g_subprocess_get_if_signaled (GSubprocess *subprocess)
   g_return_val_if_fail (G_IS_SUBPROCESS (subprocess), FALSE);
   g_return_val_if_fail (subprocess->pid == 0, FALSE);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   return WIFSIGNALED (subprocess->status);
 #else
   return FALSE;
@@ -1220,12 +1232,12 @@ g_subprocess_get_term_sig (GSubprocess *subprocess)
   g_return_val_if_fail (G_IS_SUBPROCESS (subprocess), 0);
   g_return_val_if_fail (subprocess->pid == 0, 0);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   g_return_val_if_fail (WIFSIGNALED (subprocess->status), 0);
 
   return WTERMSIG (subprocess->status);
 #else
-  g_critical ("g_subprocess_get_term_sig() called on Windows, where "
+  g_critical ("g_subprocess_get_term_sig() called on Windows or Wasm, where "
               "g_subprocess_get_if_signaled() always returns FALSE...");
   return 0;
 #endif
@@ -1440,7 +1452,7 @@ g_subprocess_communicate_internal (GSubprocess         *subprocess,
     {
       g_assert (stdin_buf != NULL);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       /* We're doing async writes to the pipe, and the async write mechanism assumes
        * that streams polling as writable do SOME progress (possibly partial) and then
        * stop, but never block.
diff --git a/gio/gtestdbus.c b/gio/gtestdbus.c
index 1111111..2222222 100644
--- a/gio/gtestdbus.c
+++ b/gio/gtestdbus.c
@@ -48,7 +48,7 @@
 
 #include "glibintl.h"
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "glib-unix.h"
 #endif
 
@@ -603,7 +603,7 @@ static gboolean
 make_pipe (gint     pipe_fds[2],
            GError **error)
 {
-#if defined(G_OS_UNIX)
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   return g_unix_open_pipe (pipe_fds, FD_CLOEXEC, error);
 #elif defined(G_OS_WIN32)
   if (_pipe (pipe_fds, 4096, _O_BINARY) < 0)
diff --git a/gio/gunixfdlist.c b/gio/gunixfdlist.c
index 1111111..2222222 100644
--- a/gio/gunixfdlist.c
+++ b/gio/gunixfdlist.c
@@ -54,6 +54,10 @@
 #include "glib/glib-private.h"
 #include "glib/gstdio.h"
 
+#ifdef G_OS_UNIX
+#include <unistd.h>  /* dup() */
+#endif
+
 #ifdef G_OS_WIN32
 #include <io.h>
 #endif
diff --git a/gio/meson.build b/gio/meson.build
index 1111111..2222222 100644
--- a/gio/meson.build
+++ b/gio/meson.build
@@ -350,7 +350,7 @@ gdbus_daemon_sources = [
   gdbus_daemon_generated,
 ]
 
-if host_system != 'windows'
+if host_system not in ['windows', 'emscripten']
   unix_sources = files(
     'gfiledescriptorbased.c',
     'giounix-private.c',
@@ -413,7 +413,7 @@ if host_system != 'windows'
       'gnetworkmonitornm.c',
     )
   endif
-else
+elif host_system == 'windows'
   appinfo_sources += files('gwin32appinfo.c')
   contenttype_sources += files('gcontenttype-win32.c')
   platform_deps += [cc.find_library('shlwapi'),
@@ -872,7 +872,7 @@ if host_system == 'windows'
     description : 'Windows specific headers for glib I/O library',
   )
   meson.override_dependency('gio-windows-2.0', libgio_dep)
-else
+elif host_system != 'emscripten'
   pkg.generate(requires : ['gobject-2.0', 'gio-2.0'],
     subdirs : ['gio-unix-2.0'],
     version : glib_version,
diff --git a/glib/gbacktrace.c b/glib/gbacktrace.c
index 1111111..2222222 100644
--- a/glib/gbacktrace.c
+++ b/glib/gbacktrace.c
@@ -259,7 +259,7 @@ g_on_error_query (const gchar *prg_name)
 void
 g_on_error_stack_trace (const gchar *prg_name)
 {
-#if defined(G_OS_UNIX)
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   pid_t pid;
   gchar buf[16];
   const gchar *args[5] = { DEBUGGER, NULL, NULL, NULL, NULL };
@@ -301,9 +301,11 @@ g_on_error_stack_trace (const gchar *prg_name)
         break;
     }
 #else
+#ifdef G_OS_WIN32
   if (IsDebuggerPresent ())
     G_BREAKPOINT ();
   else
+#endif
     g_abort ();
 #endif
 }
diff --git a/glib/gmain.c b/glib/gmain.c
index 1111111..2222222 100644
--- a/glib/gmain.c
+++ b/glib/gmain.c
@@ -48,7 +48,7 @@
 #define G_MAIN_POLL_DEBUG
 #endif
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "glib-unix.h"
 #include <pthread.h>
 #ifdef HAVE_EVENTFD
@@ -369,7 +369,7 @@ struct _GChildWatchSource
   gint        child_status;
   /* @poll is always used on Windows, and used on Unix iff @using_pidfd is set: */
   GPollFD     poll;
-#ifndef G_OS_WIN32
+#if !defined(G_OS_WIN32) && !defined(G_PLATFORM_WASM) 
   gboolean    child_exited; /* (atomic); not used iff @using_pidfd is set */
   gboolean    using_pidfd;
 #endif /* G_OS_WIN32 */
@@ -464,7 +464,7 @@ static gboolean g_child_watch_dispatch (GSource     *source,
 					GSourceFunc  callback,
 					gpointer     user_data);
 static void     g_child_watch_finalize (GSource     *source);
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static void g_unix_signal_handler (int signum);
 static gboolean g_unix_signal_watch_prepare  (GSource     *source,
 					      gint        *timeout);
@@ -485,7 +485,7 @@ static void block_source (GSource *source);
 
 static GMainContext *glib_worker_context;
 
-#ifndef G_OS_WIN32
+#if !defined(G_OS_WIN32) && !defined(G_PLATFORM_WASM) 
 
 
 /* UNIX signals work by marking one of these variables then waking the
@@ -526,7 +526,7 @@ GSourceFuncs g_unix_signal_funcs =
   g_unix_signal_watch_finalize,
   NULL, NULL
 };
-#endif /* !G_OS_WIN32 */
+#endif /* !G_OS_WIN32 && !G_PLATFORM_WASM */
 G_LOCK_DEFINE_STATIC (main_context_list);
 static GSList *main_context_list = NULL;
 
@@ -2695,7 +2695,7 @@ g_clear_handle_id (guint            *tag_ptr,
     }
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 /**
  * g_source_add_unix_fd:
  * @source: a #GSource
@@ -2877,7 +2877,7 @@ g_source_query_unix_fd (GSource  *source,
 
   return poll_fd->revents;
 }
-#endif /* G_OS_UNIX */
+#endif /* G_OS_UNIX && !G_PLATFORM_WASM */
 
 /**
  * g_get_current_time:
@@ -5406,7 +5406,28 @@ g_child_watch_finalize (GSource *source)
 {
 }
 
-#else /* G_OS_WIN32 */
+#elif defined(G_PLATFORM_WASM) /* G_OS_WIN32 */
+
+static gboolean
+g_child_watch_prepare (GSource *source,
+                       gint    *timeout)
+{
+  *timeout = -1;
+  return FALSE;
+}
+
+static gboolean 
+g_child_watch_check (GSource  *source)
+{
+  return FALSE;
+}
+
+static void
+g_child_watch_finalize (GSource *source)
+{
+}
+
+#else /* G_PLATFORM_WASM */
 
 static void
 wake_source (GSource *source)
@@ -5841,7 +5862,7 @@ g_child_watch_dispatch (GSource    *source,
   return FALSE;
 }
 
-#ifndef G_OS_WIN32
+#if !defined(G_OS_WIN32) && !defined(G_PLATFORM_WASM) 
 
 static void
 g_unix_signal_handler (int signum)
@@ -5862,7 +5883,7 @@ g_unix_signal_handler (int signum)
   errno = saved_errno;
 }
 
-#endif /* !G_OS_WIN32 */
+#endif /* !G_OS_WIN32 && !G_PLATFORM_WASM */
 
 /**
  * g_child_watch_source_new:
@@ -5932,7 +5953,7 @@ g_child_watch_source_new (GPid pid)
   child_watch_source->poll.events = G_IO_IN;
 
   g_source_add_poll (source, &child_watch_source->poll);
-#else /* !G_OS_WIN32 */
+#elif !defined(G_PLATFORM_WASM) /* !G_OS_WIN32 */
 
 #ifdef HAVE_PIDFD
   /* Use a pidfd, if possible, to avoid having to install a global SIGCHLD
@@ -6413,7 +6434,7 @@ glib_worker_main (gpointer data)
     {
       g_main_context_iteration (glib_worker_context, TRUE);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       if (g_atomic_int_get (&any_unix_signal_pending))
         dispatch_unix_signals ();
 #endif
@@ -6430,7 +6451,7 @@ g_get_worker_context (void)
   if (g_once_init_enter (&initialised))
     {
       /* mask all signals in the worker thread */
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       sigset_t prev_mask;
       sigset_t all;
 
@@ -6439,7 +6460,7 @@ g_get_worker_context (void)
 #endif
       glib_worker_context = g_main_context_new ();
       g_thread_new ("gmain", glib_worker_main, NULL);
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       pthread_sigmask (SIG_SETMASK, &prev_mask, NULL);
 #endif
       g_once_init_leave (&initialised, TRUE);
diff --git a/glib/gspawn-wasm.c b/glib/gspawn-wasm.c
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/glib/gspawn-wasm.c
@@ -0,0 +1,164 @@
+/* gspawn-wasm.c - Process launching on WebAssembly, no-op implementation
+ *
+ *  Copyright 2022 Kleis Auke Wolthuizen
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include "glib.h"
+#include "glibintl.h"
+#include "gspawn.h"
+
+G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
+G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
+
+gboolean
+g_spawn_async (const gchar          *working_directory,
+               gchar               **argv,
+               gchar               **envp,
+               GSpawnFlags           flags,
+               GSpawnChildSetupFunc  child_setup,
+               gpointer              user_data,
+               GPid                 *child_pid,
+               GError              **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_async is no-op on WebAssembly"));
+  return FALSE;
+}
+
+gboolean
+g_spawn_async_with_pipes (const gchar          *working_directory,
+                          gchar               **argv,
+                          gchar               **envp,
+                          GSpawnFlags           flags,
+                          GSpawnChildSetupFunc  child_setup,
+                          gpointer              user_data,
+                          GPid                 *child_pid,
+                          gint                 *standard_input,
+                          gint                 *standard_output,
+                          gint                 *standard_error,
+                          GError              **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_async_with_pipes is no-op on WebAssembly"));
+  return FALSE;
+}
+
+gboolean
+g_spawn_async_with_pipes_and_fds (const gchar           *working_directory,
+                                  const gchar * const   *argv,
+                                  const gchar * const   *envp,
+                                  GSpawnFlags            flags,
+                                  GSpawnChildSetupFunc   child_setup,
+                                  gpointer               user_data,
+                                  gint                   stdin_fd,
+                                  gint                   stdout_fd,
+                                  gint                   stderr_fd,
+                                  const gint            *source_fds,
+                                  const gint            *target_fds,
+                                  gsize                  n_fds,
+                                  GPid                  *child_pid_out,
+                                  gint                  *stdin_pipe_out,
+                                  gint                  *stdout_pipe_out,
+                                  gint                  *stderr_pipe_out,
+                                  GError               **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_async_with_pipes_and_fds is no-op on WebAssembly"));
+  return FALSE;
+}
+
+gboolean
+g_spawn_async_with_fds (const gchar          *working_directory,
+                        gchar               **argv,
+                        gchar               **envp,
+                        GSpawnFlags           flags,
+                        GSpawnChildSetupFunc  child_setup,
+                        gpointer              user_data,
+                        GPid                 *child_pid,
+                        gint                  stdin_fd,
+                        gint                  stdout_fd,
+                        gint                  stderr_fd,
+                        GError              **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_async_with_fds is no-op on WebAssembly"));
+  return FALSE;
+}
+
+gboolean
+g_spawn_sync (const gchar          *working_directory,
+              gchar               **argv,
+              gchar               **envp,
+              GSpawnFlags           flags,
+              GSpawnChildSetupFunc  child_setup,
+              gpointer              user_data,
+              gchar               **standard_output,
+              gchar               **standard_error,
+              gint                 *wait_status,
+              GError              **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_sync is no-op on WebAssembly"));
+  return FALSE;
+}
+
+gboolean
+g_spawn_command_line_sync (const gchar  *command_line,
+                           gchar       **standard_output,
+                           gchar       **standard_error,
+                           gint         *wait_status,
+                           GError      **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_command_line_sync is no-op on WebAssembly"));
+  return FALSE;
+}
+
+gboolean
+g_spawn_command_line_async (const gchar *command_line,
+                            GError     **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_command_line_async is no-op on WebAssembly"));
+  return FALSE;
+}
+
+gboolean
+g_spawn_check_wait_status (gint      wait_status,
+			   GError  **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_check_wait_status is no-op on WebAssembly"));
+  return FALSE;
+}
+
+gboolean
+g_spawn_check_exit_status (gint      wait_status,
+                           GError  **error)
+{
+  g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+                       _("g_spawn_check_exit_status is no-op on WebAssembly"));
+  return FALSE;
+}
+
+void
+g_spawn_close_pid (GPid pid)
+{
+}
diff --git a/glib/gthread.c b/glib/gthread.c
index 1111111..2222222 100644
--- a/glib/gthread.c
+++ b/glib/gthread.c
@@ -56,6 +56,10 @@
 #include <windows.h>
 #endif /* G_OS_WIN32 */
 
+#ifdef G_PLATFORM_WASM
+#include <emscripten/threading.h>
+#endif /*G_PLATFORM_WASM*/
+
 #include "gslice.h"
 #include "gstrfuncs.h"
 #include "gtestutils.h"
@@ -1070,7 +1074,9 @@ g_thread_self (void)
 guint
 g_get_num_processors (void)
 {
-#ifdef G_OS_WIN32
+#ifdef G_PLATFORM_WASM
+  return emscripten_num_logical_cores();
+#elif defined(G_OS_WIN32)
   unsigned int count;
   SYSTEM_INFO sysinfo;
   DWORD_PTR process_cpus;
diff --git a/glib/gtimezone.c b/glib/gtimezone.c
index 1111111..2222222 100644
--- a/glib/gtimezone.c
+++ b/glib/gtimezone.c
@@ -207,7 +207,7 @@ static GTimeZone *tz_local = NULL;
                            there's no point in getting carried
                            away. */
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static GTimeZone *parse_footertz (const gchar *, size_t);
 #endif
 
@@ -441,7 +441,7 @@ zone_for_constant_offset (GTimeZone *gtz, const gchar *name)
   gtz->transitions = NULL;
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 
 #if defined(__sun) && defined(__SVR4)
 /*
@@ -1666,7 +1666,7 @@ rules_from_identifier (const gchar   *identifier,
   return create_ruleset_from_rule (rules, &tzr);
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static GTimeZone *
 parse_footertz (const gchar *footer, size_t footerlen)
 {
@@ -1825,7 +1825,9 @@ g_time_zone_new_identifier (const gchar *identifier)
   else
     {
       G_LOCK (tz_default);
-#ifdef G_OS_UNIX
+#ifdef G_PLATFORM_WASM
+      resolved_identifier = "UTC0";
+#elif defined (G_OS_UNIX)
       resolved_identifier = zone_identifier_unix ();
 #elif defined (G_OS_WIN32)
       resolved_identifier = windows_default_tzname ();
@@ -1865,7 +1867,7 @@ g_time_zone_new_identifier (const gchar *identifier)
 
   if (tz->t_info == NULL)
     {
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       GBytes *zoneinfo = zone_info_unix (identifier, resolved_identifier);
       if (zoneinfo != NULL)
         {
diff --git a/glib/gutils.c b/glib/gutils.c
index 1111111..2222222 100644
--- a/glib/gutils.c
+++ b/glib/gutils.c
@@ -1414,7 +1414,7 @@ get_windows_version (gboolean with_windows)
 }
 #endif
 
-#if defined (G_OS_UNIX) && !defined (__APPLE__)
+#if defined (G_OS_UNIX) && !defined (__APPLE__) && !defined (G_PLATFORM_WASM)
 static gchar *
 get_os_info_from_os_release (const gchar *key_name,
                              const gchar *buffer)
@@ -1571,6 +1571,11 @@ g_get_os_info (const gchar *key_name)
     return g_strdup ("macOS");
   else
     return NULL;
+#elif defined (G_PLATFORM_WASM)
+  if (g_strcmp0 (key_name, G_OS_INFO_KEY_NAME) == 0)
+    return g_strdup ("wasm");
+  else
+    return NULL;
 #elif defined (G_OS_UNIX)
   const gchar * const os_release_files[] = { "/etc/os-release", "/usr/lib/os-release" };
   gsize i;
diff --git a/glib/gwakeup.c b/glib/gwakeup.c
index 1111111..2222222 100644
--- a/glib/gwakeup.c
+++ b/glib/gwakeup.c
@@ -111,16 +111,24 @@ g_wakeup_free (GWakeup *wakeup)
 
 #else
 
+#ifdef G_PLATFORM_WASM
+#ifdef GLIB_COMPILATION
+#include "gmessages.h"
+#endif
+#else /*!G_PLATFORM_WASM*/
 #include "glib-unix.h"
 #include <fcntl.h>
 
 #if defined (HAVE_EVENTFD)
 #include <sys/eventfd.h>
 #endif
+#endif /*G_PLATFORM_WASM*/
 
 struct _GWakeup
 {
+#ifndef G_PLATFORM_WASM
   gint fds[2];
+#endif
 };
 
 /**
@@ -137,6 +145,10 @@ struct _GWakeup
 GWakeup *
 g_wakeup_new (void)
 {
+#ifdef G_PLATFORM_WASM
+  g_error ("g_wakeup_new is no-op on WebAssembly");
+  return NULL;
+#else
   GError *error = NULL;
   GWakeup *wakeup;
 
@@ -167,6 +179,7 @@ g_wakeup_new (void)
     g_error ("Set pipes non-blocking for GWakeup: %s", error->message);
 
   return wakeup;
+#endif
 }
 
 /**
@@ -185,8 +198,12 @@ void
 g_wakeup_get_pollfd (GWakeup *wakeup,
                      GPollFD *poll_fd)
 {
+#ifdef G_PLATFORM_WASM
+  g_error ("g_wakeup_get_pollfd is no-op on WebAssembly");
+#else
   poll_fd->fd = wakeup->fds[0];
   poll_fd->events = G_IO_IN;
+#endif
 }
 
 /**
@@ -206,10 +223,14 @@ g_wakeup_get_pollfd (GWakeup *wakeup,
 void
 g_wakeup_acknowledge (GWakeup *wakeup)
 {
+#ifdef G_PLATFORM_WASM
+  g_error ("g_wakeup_acknowledge is no-op on WebAssembly");
+#else
   char buffer[16];
 
   /* read until it is empty */
   while (read (wakeup->fds[0], buffer, sizeof buffer) == sizeof buffer);
+#endif
 }
 
 /**
@@ -229,6 +250,9 @@ g_wakeup_acknowledge (GWakeup *wakeup)
 void
 g_wakeup_signal (GWakeup *wakeup)
 {
+#ifdef G_PLATFORM_WASM
+  g_error ("g_wakeup_signal is no-op on WebAssembly");
+#else
   int res;
 
   if (wakeup->fds[1] == -1)
@@ -251,6 +275,7 @@ g_wakeup_signal (GWakeup *wakeup)
         res = write (wakeup->fds[1], &one, sizeof one);
       while (G_UNLIKELY (res == -1 && errno == EINTR));
     }
+#endif
 }
 
 /**
@@ -265,12 +290,16 @@ g_wakeup_signal (GWakeup *wakeup)
 void
 g_wakeup_free (GWakeup *wakeup)
 {
+#ifdef G_PLATFORM_WASM
+  g_error ("g_wakeup_free is no-op on WebAssembly");
+#else
   close (wakeup->fds[0]);
 
   if (wakeup->fds[1] != -1)
     close (wakeup->fds[1]);
 
   g_slice_free (GWakeup, wakeup);
+#endif
 }
 
 #endif /* !_WIN32 */
diff --git a/glib/meson.build b/glib/meson.build
index 1111111..2222222 100644
--- a/glib/meson.build
+++ b/glib/meson.build
@@ -329,9 +329,10 @@ if host_system == 'windows'
   if cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl'
     glib_sources += files('dirent/wdirent.c')
   endif
+elif host_system == 'emscripten'
+  glib_sources += files('gspawn-wasm.c')
 else
   glib_sources += files('glib-unix.c', 'gspawn.c', 'giounix.c')
-  platform_deps = []
 endif
 
 if host_system == 'linux'
diff --git a/gobject/gsourceclosure.c b/gobject/gsourceclosure.c
index 1111111..2222222 100644
--- a/gobject/gsourceclosure.c
+++ b/gobject/gsourceclosure.c
@@ -25,7 +25,7 @@
 #include "gmarshal.h"
 #include "gvalue.h"
 #include "gvaluetypes.h"
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 #include "glib-unix.h"
 #endif
 
@@ -119,7 +119,7 @@ g_child_watch_closure_callback (GPid     pid,
 
   g_value_init (&result_value, G_TYPE_BOOLEAN);
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
   g_value_init (&params[0], G_TYPE_ULONG);
   g_value_set_ulong (&params[0], pid);
 #endif
@@ -141,7 +141,7 @@ g_child_watch_closure_callback (GPid     pid,
   return result;
 }
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
 static gboolean
 g_unix_fd_source_closure_callback (int           fd,
                                    GIOCondition  condition,
@@ -203,12 +203,12 @@ closure_callback_get (gpointer     cb_data,
         closure_callback = (GSourceFunc)io_watch_closure_callback;
       else if (source->source_funcs == &g_child_watch_funcs)
         closure_callback = (GSourceFunc)g_child_watch_closure_callback;
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       else if (source->source_funcs == &g_unix_fd_source_funcs)
         closure_callback = (GSourceFunc)g_unix_fd_source_closure_callback;
 #endif
       else if (source->source_funcs == &g_timeout_funcs ||
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
                source->source_funcs == &g_unix_signal_funcs ||
 #endif
                source->source_funcs == &g_idle_funcs)
@@ -251,7 +251,7 @@ g_source_set_closure (GSource  *source,
   g_return_if_fail (closure != NULL);
 
   if (!source->source_funcs->closure_callback &&
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
       source->source_funcs != &g_unix_fd_source_funcs &&
       source->source_funcs != &g_unix_signal_funcs &&
 #endif
@@ -276,7 +276,7 @@ g_source_set_closure (GSource  *source,
       if (marshal)
 	g_closure_set_marshal (closure, marshal);
       else if (source->source_funcs == &g_idle_funcs ||
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(G_PLATFORM_WASM)
                source->source_funcs == &g_unix_signal_funcs ||
 #endif
                source->source_funcs == &g_timeout_funcs)
diff --git a/meson.build b/meson.build
index 1111111..2222222 100644
--- a/meson.build
+++ b/meson.build
@@ -276,6 +276,9 @@ if host_system == 'windows'
 elif host_system == 'cygwin'
   glib_os = '''#define G_OS_UNIX
 #define G_WITH_CYGWIN'''
+elif host_system == 'emscripten'
+  glib_os = '''#define G_OS_UNIX
+#define G_PLATFORM_WASM'''
 else
   glib_os = '#define G_OS_UNIX'
 endif
@@ -1660,6 +1663,8 @@ glibconfig_conf.set('gssizebits', ssizet_size * 8)
 # XXX: https://gitlab.gnome.org/GNOME/glib/issues/1413
 if host_system == 'windows'
   g_module_suffix = 'dll'
+elif host_system == 'emscripten'
+  g_module_suffix = 'wasm'
 else
   g_module_suffix = 'so'
 endif
