From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 5 Aug 2020 16:15:00 +0200
Subject: [PATCH 1/1] Remove orc dependency

Since it is not supported in WASM.

Upstream-Status: Inappropriate [disable feature]
This patch is just for our convenience.

diff --git a/README.md b/README.md
index 1111111..2222222 100644
--- a/README.md
+++ b/README.md
@@ -226,11 +226,6 @@ enabling a package with such a large attack surface.
 If available, libvips adds support for text rendering. You need the
 package pangocairo in `pkg-config --list-all`.
 
-### orc-0.4
-
-If available, vips will accelerate some operations with this run-time
-compiler.
-
 ### matio
 
 If available, vips can load images from Matlab save files.
diff --git a/configure.ac b/configure.ac
index 1111111..2222222 100644
--- a/configure.ac
+++ b/configure.ac
@@ -731,45 +731,6 @@ AS_IF([test x"$with_magick_module" = x"yes"],
    VIPS_LIBS="$VIPS_LIBS $MAGICK_LIBS"])
 AM_CONDITIONAL(MAGICK_MODULE, [test x"$with_magick_module" = x"yes"])
 
-# orc
-AC_ARG_WITH([orc], 
-  AS_HELP_STRING([--without-orc], [build without orc (default: test)]))
-
-if test x"$with_orc" != x"no"; then
-  # we use loadpw etc.
-  PKG_CHECK_MODULES(ORC, orc-0.4 >= 0.4.11,
-    [AC_DEFINE(HAVE_ORC,1,[define if you have orc-0.4.11 or later installed.])
-     with_orc=yes
-     PACKAGES_USED="$PACKAGES_USED orc-0.4"
-     save_LIBS="$LIBS"
-     LIBS="$LIBS $ORC_LIBS"
-     AC_CHECK_FUNCS(orc_program_get_error,
-       AC_DEFINE(HAVE_ORC_PROGRAM_GET_ERROR,1,
-              [define if your orc has orc_program_get_error.]))
-     LIBS="$save_LIBS"
-    ],
-    [AC_MSG_WARN([orc-0.4.11 or later not found; disabling orc support])
-     with_orc=no
-    ]
-  )
-fi
-
-# orc 0.4.30+ works with cf-protection, but 0.4.30 has a bug with multiple
-# definitions of OrcTargetPowerPCFlags, so insist on 0.4.31
-if test x"$with_orc" = x"yes"; then
-  PKG_CHECK_MODULES(ORC_CF_PROTECTION, orc-0.4 >= 0.4.31,
-    [AC_DEFINE(HAVE_ORC_CF_PROTECTION,1,
-               [define if your orc works with cf-protection.]
-     )
-    ],
-    [:
-    ]
-  )
-fi
-
-VIPS_CFLAGS="$VIPS_CFLAGS $ORC_CFLAGS"
-VIPS_LIBS="$VIPS_LIBS $ORC_LIBS"
-
 # lcms ... refuse to use lcms1
 AC_ARG_WITH([lcms], 
   AS_HELP_STRING([--without-lcms], [build without lcms (default: test)]))
@@ -1555,7 +1516,6 @@ enable debug: $enable_debug, \
 enable deprecated library components: $enable_deprecated, \
 enable modules: $gmodule_supported_flag, \
 use fftw3 for FFT: $with_fftw, \
-accelerate loops with orc: $with_orc, \
 ICC profile support with lcms: $with_lcms, \
 zlib: $with_zlib, \
 text rendering with pangocairo: $with_pangocairo, \
@@ -1663,8 +1623,6 @@ GIF load:                               $with_nsgif
 
 ## Optional dependencies
 use fftw3 for FFT:                      $with_fftw
-accelerate loops with orc:              $with_orc
- (requires orc-0.4.11 or later)
 ICC profile support with lcms:          $with_lcms
 zlib:                                   $with_zlib
 text rendering with pangocairo:         $with_pangocairo
diff --git a/libvips/arithmetic/abs.c b/libvips/arithmetic/abs.c
index 1111111..2222222 100644
--- a/libvips/arithmetic/abs.c
+++ b/libvips/arithmetic/abs.c
@@ -80,39 +80,11 @@ typedef VipsUnaryClass VipsAbsClass;
 
 G_DEFINE_TYPE( VipsAbs, vips_abs, VIPS_TYPE_UNARY );
 
-static void *
-vips_abs_orc_init_cb( void *a )
-{
-	VipsAbs *abs = (VipsAbs *) a;
-	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_GET_CLASS( abs );
-
-	VipsVector *v;
-
-	vips_arithmetic_set_vector( aclass ); 
-
-	v = vips_arithmetic_get_program( aclass, VIPS_FORMAT_CHAR );
-	vips_vector_asm2( v, "absb", "d1", "s1" ); 
-
-	v = vips_arithmetic_get_program( aclass, VIPS_FORMAT_SHORT );
-	vips_vector_asm2( v, "absw", "d1", "s1" ); 
-
-	v = vips_arithmetic_get_program( aclass, VIPS_FORMAT_INT );
-	vips_vector_asm2( v, "absl", "d1", "s1" ); 
-
-	vips_arithmetic_compile( aclass );
-
-	return( NULL );
-}
-
 static int
 vips_abs_build( VipsObject *object )
 {
-	static GOnce once = G_ONCE_INIT;
-
 	VipsUnary *unary = (VipsUnary *) object;
 
-	VIPS_ONCE( &once, vips_abs_orc_init_cb, object ); 
-
 	if( unary->in &&
 		vips_band_format_isuint( unary->in->BandFmt ) ) 
 		return( vips_unary_copy( unary ) ); 
@@ -195,36 +167,21 @@ static void
 vips_abs_buffer( VipsArithmetic *arithmetic, 
 	VipsPel *out, VipsPel **in, int width )
 {
-	VipsArithmeticClass *class = VIPS_ARITHMETIC_GET_CLASS( arithmetic );
 	VipsImage *im = arithmetic->ready[0];
 	const int bands = vips_image_get_bands( im );
 	int sz = width * bands;
 
-	VipsVector *v;
-
-	if( (v = vips_arithmetic_get_vector( class, 
-		vips_image_get_format( im ) )) ) {
-		VipsExecutor ex;
-
-		vips_executor_set_program( &ex, v, sz );
-		vips_executor_set_array( &ex, v->s[0], in[0] );
-		vips_executor_set_destination( &ex, out );
-
-		vips_executor_run( &ex );
-	}
-	else {
-		switch( vips_image_get_format( im ) ) {
-		case VIPS_FORMAT_CHAR: 		ABS_INT( signed char ); break; 
-		case VIPS_FORMAT_SHORT: 	ABS_INT( signed short ); break; 
-		case VIPS_FORMAT_INT: 		ABS_INT( signed int ); break; 
-		case VIPS_FORMAT_FLOAT: 	ABS_FLOAT( float ); break; 
-		case VIPS_FORMAT_DOUBLE:	ABS_FLOAT( double ); break; 
-		case VIPS_FORMAT_COMPLEX:	ABS_COMPLEX( float ); break;
-		case VIPS_FORMAT_DPCOMPLEX:	ABS_COMPLEX( double ); break;
-
-		default:
-			g_assert_not_reached();
-		}
+	switch( vips_image_get_format( im ) ) {
+	case VIPS_FORMAT_CHAR: 		ABS_INT( signed char ); break; 
+	case VIPS_FORMAT_SHORT: 	ABS_INT( signed short ); break; 
+	case VIPS_FORMAT_INT: 		ABS_INT( signed int ); break; 
+	case VIPS_FORMAT_FLOAT: 	ABS_FLOAT( float ); break; 
+	case VIPS_FORMAT_DOUBLE:	ABS_FLOAT( double ); break; 
+	case VIPS_FORMAT_COMPLEX:	ABS_COMPLEX( float ); break;
+	case VIPS_FORMAT_DPCOMPLEX:	ABS_COMPLEX( double ); break;
+
+	default:
+		g_assert_not_reached();
 	}
 }
 
diff --git a/libvips/arithmetic/arithmetic.c b/libvips/arithmetic/arithmetic.c
index 1111111..2222222 100644
--- a/libvips/arithmetic/arithmetic.c
+++ b/libvips/arithmetic/arithmetic.c
@@ -752,83 +752,6 @@ vips_arithmetic_set_format_table( VipsArithmeticClass *class,
 	class->format_table = format_table;
 }
 
-void 
-vips_arithmetic_set_vector( VipsArithmeticClass *class ) 
-{
-	int i;
-
-	g_assert( class->format_table );
-
-	for( i = 0; i < VIPS_FORMAT_LAST; i++ ) {
-		int isize = vips_format_sizeof( i );
-		int osize = vips_format_sizeof( (int) class->format_table[i] );
-
-		VipsVector *v;
-
-		v = vips_vector_new( "arithmetic", osize );
-
-		vips_vector_source_name( v, "s1", isize );
-		vips_vector_source_name( v, "s2", isize );
-		vips_vector_temporary( v, "t1", osize );
-		vips_vector_temporary( v, "t2", osize );
-
-		class->vectors[i] = v;
-	}
-}
-
-/* Get the stub for this program ... use _get_vector() to get the compiled
- * code.
- */
-VipsVector *
-vips_arithmetic_get_program( VipsArithmeticClass *class, VipsBandFormat fmt )
-{
-	g_assert( (int) fmt >= 0 && (int) fmt < VIPS_FORMAT_LAST );
-	g_assert( !class->vector_program[fmt] );
-
-	class->vector_program[fmt] = TRUE;
-
-	return( class->vectors[fmt] );
-}
-
-/* Get the compiled code for this type, if available.
- */
-VipsVector *
-vips_arithmetic_get_vector( VipsArithmeticClass *class, VipsBandFormat fmt )
-{
-	g_assert( fmt >= 0 && fmt < VIPS_FORMAT_LAST );
-
-	if( !vips_vector_isenabled() ||
-		!class->vector_program[fmt] )
-		return( NULL );
-
-	return( class->vectors[fmt] );
-}
-
-void
-vips_arithmetic_compile( VipsArithmeticClass *class ) 
-{
-	int i;
-
-	g_assert( class->format_table );
-
-	for( i = 0; i < VIPS_FORMAT_LAST; i++ ) 
-		if( class->vector_program[i] &&
-			!vips_vector_compile( class->vectors[i] ) )
-			/* If compilation fails, turn off the vector for this
-			 * type.
-			 */
-			class->vector_program[i] = FALSE;
-
-#ifdef DEBUG
-	printf( "vips_arithmetic_compile: " );
-	for( i = 0; i < VIPS_FORMAT_LAST; i++ ) 
-		if( class->vector_program[i] )
-			printf( "%s ", 
-				vips_enum_nick( VIPS_TYPE_BAND_FORMAT, i ) );
-	printf( "\n" );
-#endif /*DEBUG*/
-}
-
 /* Called from iofuncs to init all operations in this dir. Use a plugin system
  * instead?
  */
diff --git a/libvips/arithmetic/parithmetic.h b/libvips/arithmetic/parithmetic.h
index 1111111..2222222 100644
--- a/libvips/arithmetic/parithmetic.h
+++ b/libvips/arithmetic/parithmetic.h
@@ -36,7 +36,6 @@ extern "C" {
 #endif /*__cplusplus*/
 
 #include <vips/vips.h>
-#include <vips/vector.h>
 
 #define VIPS_TYPE_ARITHMETIC (vips_arithmetic_get_type())
 #define VIPS_ARITHMETIC( obj ) \
@@ -91,14 +90,6 @@ typedef struct _VipsArithmeticClass {
 	 */
 	const VipsBandFormat *format_table;
 
-	/* A vector program for each input type.
-	 */
-	VipsVector *vectors[VIPS_FORMAT_LAST];
-
-	/* ... and if we've set a program for this format.
-	 */
-	gboolean vector_program[VIPS_FORMAT_LAST];
-
 	/* The buffer processor.
 	 */
 	VipsArithmeticProcessFn process_line;
@@ -107,13 +98,7 @@ typedef struct _VipsArithmeticClass {
 GType vips_arithmetic_get_type( void );
 
 void vips_arithmetic_set_format_table( VipsArithmeticClass *klass, 
-	const VipsBandFormat *format_table ); 
-void vips_arithmetic_set_vector( VipsArithmeticClass *klass );
-VipsVector *vips_arithmetic_get_vector( VipsArithmeticClass *klass, 
-	VipsBandFormat fmt );
-void vips_arithmetic_compile( VipsArithmeticClass *klass ); 
-VipsVector *vips_arithmetic_get_program( VipsArithmeticClass *klass, 
-	VipsBandFormat fmt );
+	const VipsBandFormat *format_table );
 
 #ifdef __cplusplus
 }
diff --git a/libvips/arithmetic/statistic.h b/libvips/arithmetic/statistic.h
index 1111111..2222222 100644
--- a/libvips/arithmetic/statistic.h
+++ b/libvips/arithmetic/statistic.h
@@ -35,8 +35,6 @@
 extern "C" {
 #endif /*__cplusplus*/
 
-#include <vips/vector.h>
-
 #define VIPS_TYPE_STATISTIC (vips_statistic_get_type())
 #define VIPS_STATISTIC( obj ) \
 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
diff --git a/libvips/conversion/pconversion.h b/libvips/conversion/pconversion.h
index 1111111..2222222 100644
--- a/libvips/conversion/pconversion.h
+++ b/libvips/conversion/pconversion.h
@@ -35,8 +35,6 @@
 extern "C" {
 #endif /*__cplusplus*/
 
-#include <vips/vector.h>
-
 #define VIPS_TYPE_CONVERSION (vips_conversion_get_type())
 #define VIPS_CONVERSION( obj ) \
 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
diff --git a/libvips/convolution/conva.c b/libvips/convolution/conva.c
index 1111111..2222222 100644
--- a/libvips/convolution/conva.c
+++ b/libvips/convolution/conva.c
@@ -95,7 +95,6 @@ $ vips im_max abs.v
 #include <math.h>
 
 #include <vips/vips.h>
-#include <vips/vector.h>
 #include <vips/debug.h>
 #include <vips/internal.h>
 
diff --git a/libvips/convolution/convasep.c b/libvips/convolution/convasep.c
index 1111111..2222222 100644
--- a/libvips/convolution/convasep.c
+++ b/libvips/convolution/convasep.c
@@ -83,7 +83,6 @@
 #include <math.h>
 
 #include <vips/vips.h>
-#include <vips/vector.h>
 #include <vips/debug.h>
 #include <vips/internal.h>
 
diff --git a/libvips/convolution/convf.c b/libvips/convolution/convf.c
index 1111111..2222222 100644
--- a/libvips/convolution/convf.c
+++ b/libvips/convolution/convf.c
@@ -78,6 +78,10 @@
 
  */
 
+/* 
+#define DEBUG
+ */
+
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /*HAVE_CONFIG_H*/
@@ -294,21 +298,21 @@ vips_convf_build( VipsObject *object )
 	M = convolution->M;
 	coeff = (double *) VIPS_IMAGE_ADDR( M, 0, 0 );
 	ne = M->Xsize * M->Ysize;
-        if( !(convf->coeff = VIPS_ARRAY( object, ne, double )) ||
-        	!(convf->coeff_pos = VIPS_ARRAY( object, ne, int )) )
-                return( -1 );
-
-        /* Find non-zero mask elements.
-         */
-        for( i = 0; i < ne; i++ )
-                if( coeff[i] ) {
+	if( !(convf->coeff = VIPS_ARRAY( object, ne, double )) ||
+		!(convf->coeff_pos = VIPS_ARRAY( object, ne, int )) )
+		return( -1 );
+
+	/* Find non-zero mask elements.
+	 */
+	for( i = 0; i < ne; i++ )
+		if( coeff[i] ) {
 			convf->coeff[convf->nnz] = coeff[i];
 			convf->coeff_pos[convf->nnz] = i;
 			convf->nnz += 1;
 		}
 
-	/* Was the whole mask zero? We must have at least 1 element in there:
-	 * set it to zero.
+	/* Was the whole mask zero? We must have at least 1 element 
+	 * in there: set it to zero.
 	 */
 	if( convf->nnz == 0 ) {
 		convf->coeff[0] = 0;
diff --git a/libvips/convolution/convi.c b/libvips/convolution/convi.c
index 1111111..2222222 100644
--- a/libvips/convolution/convi.c
+++ b/libvips/convolution/convi.c
@@ -109,8 +109,6 @@
 
 /* 
 #define DEBUG
-#define DEBUG_PIXELS
-#define DEBUG_COMPILE
  */
 
 #ifdef HAVE_CONFIG_H
@@ -123,56 +121,17 @@
 #include <limits.h>
 
 #include <vips/vips.h>
-#include <vips/internal.h>
 
 #include "pconvolution.h"
 
-/* Larger than this and we fall back to C.
- */
-#define MAX_PASS (20)
-
-/* A pass with a vector. 
- */
-typedef struct {
-	int first;		/* The index of the first mask coff we use */
-	int last;		/* The index of the last mask coff we use */
-
-	int r;			/* Set previous result in this var */
-
-        /* The code we generate for this section of the mask. 
-	 */
-        VipsVector *vector;
-} Pass;
-
 typedef struct {
 	VipsConvolution parent_instance;
 
-	int n_point;		/* w * h for our matrix */
-
 	/* We make a smaller version of the mask with the zeros squeezed out.
 	 */
 	int nnz;		/* Number of non-zero mask elements */
 	int *coeff;		/* Array of non-zero mask coefficients */
 	int *coeff_pos;		/* Index of each nnz element in mask->coeff */
-
-	/* And a half float version for the vector path. mant has the signed
-	 * 8-bit mantissas in [-1, +1), sexp has the exponent shift after the
-	 * mul and before the add, and exp has the final exponent shift before
-	 * write-back.
-	 */
-	int *mant;
-	int sexp;
-	int exp;
-
-	/* The set of passes we need for this mask.
-	 */
-	int n_pass;	
-	Pass pass[MAX_PASS];
-
-	/* Code for the final clip back to 8 bits.
-	 */
-	int r;			
-        VipsVector *vector;
 } VipsConvi;
 
 typedef VipsConvolutionClass VipsConviClass;
@@ -188,41 +147,8 @@ typedef struct {
 	int *offsets;		/* Offsets for each non-zero matrix element */
 
 	int last_bpl;		/* Avoid recalcing offsets, if we can */
-
-	/* We need a pair of intermediate buffers to keep the results of each
-	 * vector conv pass. 
-	 */
-	short *t1;
-	short *t2;
 } VipsConviSequence;
 
-static void
-vips_convi_compile_free( VipsConvi *convi )
-{
-	int i;
-
-	for( i = 0; i < convi->n_pass; i++ )
-		VIPS_FREEF( vips_vector_free, convi->pass[i].vector );
-	convi->n_pass = 0;
-	VIPS_FREEF( vips_vector_free, convi->vector );
-}
-
-static void
-vips_convi_dispose( GObject *gobject )
-{
-	VipsConvi *convi = (VipsConvi *) gobject;
-
-#ifdef DEBUG
-	printf( "vips_convi_dispose: " );
-	vips_object_print_name( VIPS_OBJECT( gobject ) );
-	printf( "\n" );
-#endif /*DEBUG*/
-
-	vips_convi_compile_free( convi ); 
-
-	G_OBJECT_CLASS( vips_convi_parent_class )->dispose( gobject );
-}
-
 /* Free a sequence value.
  */
 static int
@@ -232,8 +158,6 @@ vips_convi_stop( void *vseq, void *a, void *b )
 
 	VIPS_UNREF( seq->ir );
 	VIPS_FREE( seq->offsets );
-	VIPS_FREE( seq->t1 );
-	VIPS_FREE( seq->t2 );
 
 	return( 0 );
 }
@@ -252,339 +176,17 @@ vips_convi_start( VipsImage *out, void *a, void *b )
 
 	seq->convi = convi;
 	seq->ir = NULL;
-	seq->offsets = NULL;
 	seq->last_bpl = -1;
-	seq->t1 = NULL;
-	seq->t2 = NULL;
 
 	seq->ir = vips_region_new( in );
-
-	/* C mode.
-	 */
-	if( convi->nnz ) {
-		if( !(seq->offsets = VIPS_ARRAY( NULL, convi->nnz, int )) ) { 
-			vips_convi_stop( seq, in, convi );
-			return( NULL );
-		}
-	}
-
-	/* Vector mode.
-	 */
-	if( convi->n_pass ) {
-		seq->t1 = VIPS_ARRAY( NULL, VIPS_IMAGE_N_ELEMENTS( in ), short );
-		seq->t2 = VIPS_ARRAY( NULL, VIPS_IMAGE_N_ELEMENTS( in ), short );
-
-		if( !seq->t1 || 
-			!seq->t2 ) {
-			vips_convi_stop( seq, in, convi );
-			return( NULL );
-		}
+	if( !(seq->offsets = VIPS_ARRAY( NULL, convi->nnz, int )) ) { 
+		vips_convi_stop( seq, in, convi );
+		return( NULL );
 	}
 
 	return( (void *) seq );
 }
 
-#define TEMP( N, S ) vips_vector_temporary( v, (char *) N, S )
-#define PARAM( N, S ) vips_vector_parameter( v, (char *) N, S )
-#define SCANLINE( N, P, S ) vips_vector_source_scanline( v, (char *) N, P, S )
-#define CONST( N, V, S ) vips_vector_constant( v, (char *) N, V, S )
-#define ASM2( OP, A, B ) vips_vector_asm2( v, (char *) OP, A, B )
-#define ASM3( OP, A, B, C ) vips_vector_asm3( v, (char *) OP, A, B, C )
-
-/* Generate code for a section of the mask. first is the index we start
- * at, we set last to the index of the last one we use before we run 
- * out of intermediates / constants / parameters / sources or mask
- * coefficients.
- *
- * 0 for success, -1 on error.
- */
-static int
-vips_convi_compile_section( VipsConvi *convi, VipsImage *in, Pass *pass )
-{
-	VipsConvolution *convolution = (VipsConvolution *) convi;
-	VipsImage *M = convolution->M;
-
-	VipsVector *v;
-	int i;
-
-#ifdef DEBUG_COMPILE
-	printf( "starting pass %d\n", pass->first ); 
-#endif /*DEBUG_COMPILE*/
-
-	pass->vector = v = vips_vector_new( "convi", 2 );
-
-	/* "r" is the array of sums from the previous pass (if any).
-	 */
-	pass->r = vips_vector_source_name( v, "r", 2 );
-
-	/* The value we fetch from the image, the accumulated sum.
-	 */
-	TEMP( "value", 2 );
-	TEMP( "valueb", 1 );
-	TEMP( "sum", 2 );
-
-	/* Init the sum. If this is the first pass, it's a constant. If this
-	 * is a later pass, we have to init the sum from the result 
-	 * of the previous pass. 
-	 */
-	if( pass->first == 0 ) {
-		char c0[256];
-
-		CONST( c0, 0, 2 );
-		ASM2( "loadpw", "sum", c0 );
-	}
-	else 
-		ASM2( "loadw", "sum", "r" );
-
-	for( i = pass->first; i < convi->n_point; i++ ) {
-		int x = i % M->Xsize;
-		int y = i / M->Xsize;
-
-		char source[256];
-		char off[256];
-		char rnd[256];
-		char sexp[256];
-		char coeff[256];
-
-		/* Exclude zero elements.
-		 */
-		if( !convi->mant[i] )
-			continue;
-
-		/* The source. sl0 is the first scanline in the mask.
-		 */
-		SCANLINE( source, y, 1 );
-
-		/* Load with an offset. Only for non-first-columns though.
-		 */
-		if( x == 0 ) 
-			ASM2( "convubw", "value", source );
-		else {
-			CONST( off, in->Bands * x, 1 );
-			ASM3( "loadoffb", "valueb", source, off );
-			ASM2( "convubw", "value", "valueb" );
-		}
-
-		/* We need a signed multiply, so the image pixel needs to
-		 * become a signed 16-bit value. We know only the bottom 8 bits
-		 * of the image and coefficient are interesting, so we can take
-		 * the bottom half of a 16x16->32 multiply. 
-		 */
-		CONST( coeff, convi->mant[i], 2 );
-		ASM3( "mullw", "value", "value", coeff );
-
-		/* Shift right before add to prevent overflow on large masks.
-		 */
-		CONST( sexp, convi->sexp, 2 );
-		CONST( rnd, 1 << (convi->sexp - 1), 2 );
-		ASM3( "addw", "value", "value", rnd );
-		ASM3( "shrsw", "value", "value", sexp );
-
-		/* We accumulate the signed 16-bit result in sum. Saturated
-		 * add. 
-		 */
-		ASM3( "addssw", "sum", "sum", "value" );
-
-		if( vips_vector_full( v ) )
-			break;
-	}
-
-	pass->last = i;
-
-	/* And write to our intermediate buffer.
-	 */
-	ASM2( "copyw", "d1", "sum" );
-
-	if( !vips_vector_compile( v ) ) 
-		return( -1 );
-
-#ifdef DEBUG_COMPILE
-	printf( "done coeffs %d to %d\n", pass->first, pass->last );
-	vips_vector_print( v );
-#endif /*DEBUG_COMPILE*/
-
-	return( 0 );
-}
-
-/* Generate code for the final 16->8 conversion. 
- *
- * 0 for success, -1 on error.
- */
-static int
-vips_convi_compile_clip( VipsConvi *convi )
-{
-	VipsConvolution *convolution = (VipsConvolution *) convi;
-	VipsImage *M = convolution->M;
-	int offset = VIPS_RINT( vips_image_get_offset( M ) );
-
-	VipsVector *v;
-	char rnd[256];
-	char exp[256];
-	char c0[256];
-	char c255[256];
-	char off[256];
-
-	convi->vector = v = vips_vector_new( "convi", 1 );
-
-	/* "r" is the array of sums we clip down. 
-	 */
-	convi->r = vips_vector_source_name( v, "r", 2 );
-
-	/* The value we fetch from the image.
-	 */
-	TEMP( "value", 2 );
-
-	CONST( rnd, 1 << (convi->exp - 1), 2 );
-	ASM3( "addw", "value", "r", rnd );
-	CONST( exp, convi->exp, 2 );
-	ASM3( "shrsw", "value", "value", exp );
-
-	CONST( off, offset, 2 ); 
-	ASM3( "addw", "value", "value", off );
-
-	/* You'd think "convsuswb" (convert signed 16-bit to unsigned
-	 * 8-bit with saturation) would be quicker, but it's a lot
-	 * slower.
-	 */
-	CONST( c0, 0, 2 );
-	ASM3( "maxsw", "value", c0, "value" ); 
-	CONST( c255, 255, 2 );
-	ASM3( "minsw", "value", c255, "value" ); 
-
-	ASM2( "convwb", "d1", "value" );
-
-	if( !vips_vector_compile( v ) ) 
-		return( -1 );
-
-	return( 0 );
-}
-
-static int
-vips_convi_compile( VipsConvi *convi, VipsImage *in )
-{
-	int i;
-	Pass *pass;
-
-	/* Generate passes until we've used up the whole mask.
-	 */
-	for( i = 0;; ) {
-		/* Allocate space for another pass.
-		 */
-		if( convi->n_pass == MAX_PASS ) 
-			return( -1 );
-		pass = &convi->pass[convi->n_pass];
-		convi->n_pass += 1;
-
-		pass->first = i;
-		pass->r = -1;
-
-		if( vips_convi_compile_section( convi, in, pass ) )
-			return( -1 );
-		i = pass->last + 1;
-
-		if( i >= convi->n_point )
-			break;
-	}
-
-	if( vips_convi_compile_clip( convi ) )
-		return( -1 );
-
-	return( 0 );
-}
-
-static int
-vips_convi_gen_vector( VipsRegion *or, 
-	void *vseq, void *a, void *b, gboolean *stop )
-{
-	VipsConviSequence *seq = (VipsConviSequence *) vseq;
-	VipsConvi *convi = (VipsConvi *) b;
-	VipsConvolution *convolution = (VipsConvolution *) convi;
-	VipsImage *M = convolution->M;
-	VipsImage *in = (VipsImage *) a;
-	VipsRegion *ir = seq->ir;
-	VipsRect *r = &or->valid;
-	int ne = r->width * in->Bands;
-
-	VipsRect s;
-	int i, y;
-	VipsExecutor executor[MAX_PASS];
-	VipsExecutor clip;
-
-#ifdef DEBUG_PIXELS
-	printf( "vips_convi_gen_vector: generating %d x %d at %d x %d\n",
-		r->width, r->height, r->left, r->top ); 
-#endif /*DEBUG_PIXELS*/
-
-	/* Prepare the section of the input image we need. A little larger
-	 * than the section of the output image we are producing.
-	 */
-	s = *r;
-	s.width += M->Xsize - 1;
-	s.height += M->Ysize - 1;
-	if( vips_region_prepare( ir, &s ) )
-		return( -1 );
-
-	for( i = 0; i < convi->n_pass; i++ ) 
-		vips_executor_set_program( &executor[i], 
-			convi->pass[i].vector, ne );
-	vips_executor_set_program( &clip, convi->vector, ne );
-
-	VIPS_GATE_START( "vips_convi_gen_vector: work" ); 
-
-	for( y = 0; y < r->height; y ++ ) { 
-		VipsPel *q = VIPS_REGION_ADDR( or, r->left, r->top + y );
-	
-#ifdef DEBUG_PIXELS
-{
-		int h, v;
-
-		printf( "before convolve: x = %d, y = %d\n", 
-			r->left, r->top + y );
-		for( v = 0; v < M->Ysize; v++ ) {
-			for( h = 0; h < M->Xsize; h++ )
-				printf( "%3d ", *VIPS_REGION_ADDR( ir, 
-					r->left + h, r->top + y + v ) );
-			printf( "\n" );
-		}
-}
-#endif /*DEBUG_PIXELS*/
-
-		/* We run our n passes to generate this scanline.
-		 */
-		for( i = 0; i < convi->n_pass; i++ ) {
-			Pass *pass = &convi->pass[i]; 
-
-			vips_executor_set_scanline( &executor[i], 
-				ir, r->left, r->top + y );
-			vips_executor_set_array( &executor[i],
-				pass->r, seq->t1 );
-			vips_executor_set_destination( &executor[i], seq->t2 );
-			vips_executor_run( &executor[i] );
-
-			VIPS_SWAP( signed short *, seq->t1, seq->t2 );
-		}
-
-#ifdef DEBUG_PIXELS
-		printf( "before clip: %d\n", ((signed short *) seq->t1)[0] );
-#endif /*DEBUG_PIXELS*/
-
-		vips_executor_set_array( &clip, convi->r, seq->t1 );
-		vips_executor_set_destination( &clip, q ); 
-		vips_executor_run( &clip );
-
-#ifdef DEBUG_PIXELS
-		printf( "after clip: %d\n", 
-			*VIPS_REGION_ADDR( or, r->left, r->top + y ) );
-#endif /*DEBUG_PIXELS*/
-	}
-
-	VIPS_GATE_STOP( "vips_convi_gen_vector: work" ); 
-
-	VIPS_COUNT_PIXELS( or, "vips_convi_gen_vector" ); 
-
-	return( 0 );
-}
-
 /* INT inner loops.
  */
 #define CONV_INT( TYPE, CLIP ) { \
@@ -600,14 +202,12 @@ vips_convi_gen_vector( VipsRegion *or,
 		for ( i = 0; i < nnz; i++ ) \
 			sum += t[i] * p[offsets[i]]; \
 		\
-		sum = ((sum + rounding) / scale) + offset; \
-		\
-		CLIP; \
+		sum = CLIP( ((sum + rounding) / scale) + offset ); \
 		\
-		q[x] = sum;  \
+		q[x] = sum; \
 		p += 1; \
 	}  \
-} 
+}
 
 /* FLOAT inner loops.
  */
@@ -626,46 +226,18 @@ vips_convi_gen_vector( VipsRegion *or,
  		\
 		sum = (sum / scale) + offset; \
 		\
-		q[x] = sum;  \
+		q[x] = sum; \
 		p += 1; \
-	}  \
-} 
+	} \
+}
 
-/* Various integer range clips. Record over/under flows.
+/* Various integer range clips.
  */
-#define CLIP_UCHAR( V ) \
-G_STMT_START { \
-	if( (V) < 0 ) \
-		(V) = 0; \
-	else if( (V) > UCHAR_MAX ) \
-		(V) = UCHAR_MAX; \
-} G_STMT_END
-
-#define CLIP_CHAR( V ) \
-G_STMT_START { \
-	if( (V) < SCHAR_MIN ) \
-		(V) = SCHAR_MIN; \
-	else if( (V) > SCHAR_MAX ) \
-		(V) = SCHAR_MAX; \
-} G_STMT_END
-
-#define CLIP_USHORT( V ) \
-G_STMT_START { \
-	if( (V) < 0 ) \
-		(V) = 0; \
-	else if( (V) > USHRT_MAX ) \
-		(V) = USHRT_MAX; \
-} G_STMT_END
-
-#define CLIP_SHORT( V ) \
-G_STMT_START { \
-	if( (V) < SHRT_MIN ) \
-		(V) = SHRT_MIN; \
-	else if( (V) > SHRT_MAX ) \
-		(V) = SHRT_MAX; \
-} G_STMT_END
-
-#define CLIP_NONE( V ) {}
+#define CLIP_UCHAR( X ) VIPS_CLIP( 0, (X), UCHAR_MAX )
+#define CLIP_CHAR( X ) VIPS_CLIP( SCHAR_MIN, (X), SCHAR_MAX )
+#define CLIP_USHORT( X ) VIPS_CLIP( 0, (X), USHRT_MAX )
+#define CLIP_SHORT( X ) VIPS_CLIP( SHRT_MIN, (X), SHRT_MAX )
+#define CLIP_NONE( X ) (X)
 
 /* Convolve!
  */
@@ -726,27 +298,27 @@ vips_convi_gen( VipsRegion *or,
 	for( y = to; y < bo; y++ ) { 
 		switch( in->BandFmt ) {
 		case VIPS_FORMAT_UCHAR: 	
-			CONV_INT( unsigned char, CLIP_UCHAR( sum ) ); 
+			CONV_INT( unsigned char, CLIP_UCHAR ); 
 			break;
 
 		case VIPS_FORMAT_CHAR:   
-			CONV_INT( signed char, CLIP_CHAR( sum ) ); 
+			CONV_INT( signed char, CLIP_CHAR ); 
 			break;
 
 		case VIPS_FORMAT_USHORT: 
-			CONV_INT( unsigned short, CLIP_USHORT( sum ) ); 
+			CONV_INT( unsigned short, CLIP_USHORT ); 
 			break;
 
 		case VIPS_FORMAT_SHORT:  
-			CONV_INT( signed short, CLIP_SHORT( sum ) ); 
+			CONV_INT( signed short, CLIP_SHORT ); 
 			break;
 
 		case VIPS_FORMAT_UINT:   
-			CONV_INT( unsigned int, CLIP_NONE( sum ) ); 
+			CONV_INT( unsigned int, CLIP_NONE ); 
 			break;
 
 		case VIPS_FORMAT_INT:    
-			CONV_INT( signed int, CLIP_NONE( sum ) ); 
+			CONV_INT( signed int, CLIP_NONE ); 
 			break;
 
 		case VIPS_FORMAT_FLOAT:  
@@ -842,167 +414,56 @@ vips__image_intize( VipsImage *in, VipsImage **out )
 	return( 0 );
 }
 
-/* Make an int version of a mask. Each element is 8.8 float, with the same
- * exponent for each element (so just 8 bits in @out).
- *
- * @out is a w x h int array.
- */
 static int
-vips_convi_intize( VipsConvi *convi, VipsImage *M )
+vips_convi_build( VipsObject *object )
 {
-	VipsImage *t;
-	double scale;
-	double *scaled;
-	double mx;
-	double mn;
-	int shift;
-	int i;
+	VipsConvolution *convolution = (VipsConvolution *) object;
+	VipsConvi *convi = (VipsConvi *) object;
+	VipsImage **t = (VipsImage **) vips_object_local_array( object, 4 );
 
-	if( vips_check_matrix( "vips2imask", M, &t ) )
-		return( -1 ); 
+	VipsImage *in;
+	VipsImage *M;
+	double *coeff;
+	int ne;
+	int i;
 
-	/* Bake the scale into the mask to make a double version.
-	 */
-	scale = vips_image_get_scale( t );
-        if( !(scaled = VIPS_ARRAY( convi, convi->n_point, double )) ) {
-		g_object_unref( t ); 
+	if( VIPS_OBJECT_CLASS( vips_convi_parent_class )->build( object ) )
 		return( -1 );
-	}
-	for( i = 0; i < convi->n_point; i++ ) 
-		scaled[i] = VIPS_MATRIX( t, 0, 0 )[i] / scale;
-	g_object_unref( t ); 
-
-#ifdef DEBUG_COMPILE
-{
-	int x, y;
 
-	printf( "vips_convi_intize: double version\n" ); 
-	for( y = 0; y < t->Ysize; y++ ) {
-		printf( "\t" ); 
-		for( x = 0; x < t->Xsize; x++ ) 
-			printf( "%g ", scaled[y * t->Xsize + x] ); 
-		printf( "\n" ); 
-	}
-}
-#endif /*DEBUG_COMPILE*/
-
-	mx = scaled[0];
-	mn = scaled[0];
-	for( i = 1; i < convi->n_point; i++ ) {
-		if( scaled[i] > mx )
-			mx = scaled[i];
-		if( scaled[i] < mn )
-			mn = scaled[i];
-	}
+	M = convolution->M;
+	ne = M->Xsize * M->Ysize;
 
-	/* The mask max rounded up to the next power of two gives the exponent
-	 * all elements share. Values are eg. -3 for 1/8, 3 for 8.
-	 *
-	 * Add one so we round up stuff exactly on x.0. We multiply by 128
-	 * later, so 1.0 (for example) would become 128, which is outside
-	 * signed 8 bit. 
+	/* Make an int version of our mask.
 	 */
-	shift = ceil( log2( mx ) + 1 );
+	if( vips__image_intize( M, &t[1] ) )
+		return( -1 );
+	M = t[1];
 
-	/* We need to sum n_points, so we have to shift right before adding a
-	 * new value to make sure we have enough range. 
-	 */
-	convi->sexp = ceil( log2( convi->n_point ) );
-	if( convi->sexp > 10 ) {
-		g_info( "vips_convi_intize: mask too large" ); 
-		return( -1 ); 
-	}
+	coeff = VIPS_MATRIX( M, 0, 0 );
+	if( !(convi->coeff = VIPS_ARRAY( object, ne, int )) ||
+		!(convi->coeff_pos = VIPS_ARRAY( object, ne, int )) )
+	return( -1 );
 
-	/* With that already done, the final shift must be ...
+	/* Squeeze out zero mask elements. 
 	 */
-	convi->exp = 7 - shift - convi->sexp;
-
-	if( !(convi->mant = VIPS_ARRAY( convi, convi->n_point, int )) )
-		return( -1 );
-	for( i = 0; i < convi->n_point; i++ ) {
-		/* 128 since this is signed. 
-		 */
-		convi->mant[i] = VIPS_RINT( 128 * scaled[i] * pow(2, -shift) );
-
-		if( convi->mant[i] < -128 ||
-			convi->mant[i] > 127 ) {
-			g_info( "vips_convi_intize: mask range too large" ); 
-			return( -1 );
+	convi->nnz = 0;
+	for( i = 0; i < ne; i++ )
+		if( coeff[i] ) {
+			convi->coeff[convi->nnz] = coeff[i];
+			convi->coeff_pos[convi->nnz] = i;
+			convi->nnz += 1;
 		}
-	}
 
-#ifdef DEBUG_COMPILE
-{
-	int x, y;
-
-	printf( "vips_convi_intize:\n" ); 
-	printf( "sexp = %d\n", convi->sexp ); 
-	printf( "exp = %d\n", convi->exp ); 
-	for( y = 0; y < t->Ysize; y++ ) {
-		printf( "\t" ); 
-		for( x = 0; x < t->Xsize; x++ ) 
-			printf( "%4d ", convi->mant[y * t->Xsize + x] ); 
-		printf( "\n" ); 
-	}
-}
-#endif /*DEBUG_COMPILE*/
-
-	/* Verify accuracy.
+	/* Was the whole mask zero? We must have at least 1 element 
+	 * in there: set it to zero.
 	 */
-{
-	double true_sum;
-	int int_sum;
-	int true_value;
-	int int_value;
-
-	true_sum = 0.0;
-	int_sum = 0;
-	for( i = 0; i < convi->n_point; i++ ) {
-		int value;
-
-		true_sum += 128 * scaled[i];
-		value = 128 * convi->mant[i];
-		value = (value + (1 << (convi->sexp - 1))) >> convi->sexp;
-		int_sum += value;
-		int_sum = VIPS_CLIP( SHRT_MIN, int_sum, SHRT_MAX ); 
-	}
-
-	true_value = VIPS_CLIP( 0, true_sum, 255 ); 
-
-	if( convi->exp > 0 )
-		int_value = (int_sum + (1 << (convi->exp - 1))) >> convi->exp;
-	else
-		int_value = VIPS_LSHIFT_INT( int_sum, convi->exp );
-	int_value = VIPS_CLIP( 0, int_value, 255 ); 
-
-	if( VIPS_ABS( true_value - int_value ) > 2 ) {
-		g_info( "vips_convi_intize: too inaccurate" );
-		return( -1 ); 
+	if( convi->nnz == 0 ) {
+		convi->coeff[0] = 0;
+		convi->coeff_pos[0] = 0;
+		convi->nnz = 1;
 	}
-}
-
-	return( 0 );
-}
-
-static int
-vips_convi_build( VipsObject *object )
-{
-	VipsConvolution *convolution = (VipsConvolution *) object;
-	VipsConvi *convi = (VipsConvi *) object;
-	VipsImage **t = (VipsImage **) vips_object_local_array( object, 4 );
-
-	VipsImage *in;
-	VipsImage *M;
-	VipsGenerateFn generate;
-	double *coeff;
-        int i;
-
-	if( VIPS_OBJECT_CLASS( vips_convi_parent_class )->build( object ) )
-		return( -1 );
 
 	in = convolution->in;
-	M = convolution->M;
-	convi->n_point = M->Xsize * M->Ysize;
 
 	if( vips_embed( in, &t[0], 
 		M->Xsize / 2, M->Ysize / 2, 
@@ -1012,65 +473,14 @@ vips_convi_build( VipsObject *object )
 		return( -1 );
 	in = t[0]; 
 
-	/* Default to the C path.
-	 */
-	generate = vips_convi_gen;
-
-	/* For uchar input, try to make a vector path.
-	 */
-	if( vips_vector_isenabled() &&
-		in->BandFmt == VIPS_FORMAT_UCHAR ) {
-		if( !vips_convi_intize( convi, M ) &&
-			!vips_convi_compile( convi, in ) ) {
-			generate = vips_convi_gen_vector;
-			g_info( "convi: using vector path" ); 
-		}
-		else
-			vips_convi_compile_free( convi );
-	}
-
-	/* Make the data for the C path.
-	 */
-	if( generate == vips_convi_gen ) { 
-		g_info( "convi: using C path" ); 
-
-		/* Make an int version of our mask.
-		 */
-		if( vips__image_intize( M, &t[1] ) )
-			return( -1 ); 
-		M = t[1];
-
-		coeff = VIPS_MATRIX( M, 0, 0 ); 
-		if( !(convi->coeff = VIPS_ARRAY( object, convi->n_point, int )) ||
-			!(convi->coeff_pos = 
-				VIPS_ARRAY( object, convi->n_point, int )) )
-			return( -1 );
-
-		/* Squeeze out zero mask elements. 
-		 */
-		convi->nnz = 0;
-		for( i = 0; i < convi->n_point; i++ )
-			if( coeff[i] ) {
-				convi->coeff[convi->nnz] = coeff[i];
-				convi->coeff_pos[convi->nnz] = i;
-				convi->nnz += 1;
-			}
-
-		/* Was the whole mask zero? We must have at least 1 element 
-		 * in there: set it to zero.
-		 */
-		if( convi->nnz == 0 ) {
-			convi->coeff[0] = 0;
-			convi->coeff_pos[0] = 0;
-			convi->nnz = 1;
-		}
-	}
-
 	g_object_set( convi, "out", vips_image_new(), NULL ); 
 	if( vips_image_pipelinev( convolution->out, 
 		VIPS_DEMAND_STYLE_SMALLTILE, in, NULL ) )
 		return( -1 );
 
+	convolution->out->Xoffset = 0;
+	convolution->out->Yoffset = 0;
+
 	/* Prepare output. Consider a 7x7 mask and a 7x7 image --- the output
 	 * would be 1x1.
 	 */
@@ -1078,7 +488,7 @@ vips_convi_build( VipsObject *object )
 	convolution->out->Ysize -= M->Ysize - 1;
 
 	if( vips_image_generate( convolution->out, 
-		vips_convi_start, generate, vips_convi_stop, in, convi ) )
+		vips_convi_start, vips_convi_gen, vips_convi_stop, in, convi ) )
 		return( -1 );
 
 	convolution->out->Xoffset = -M->Xsize / 2;
@@ -1090,11 +1090,8 @@ vips_convi_build( VipsObject *object )
 static void
 vips_convi_class_init( VipsConviClass *class )
 {
-	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
 	VipsObjectClass *object_class = (VipsObjectClass *) class;
 
-	gobject_class->dispose = vips_convi_dispose;
-
 	object_class->nickname = "convi";
 	object_class->description = _( "int convolution operation" );
 	object_class->build = vips_convi_build;
diff --git a/libvips/convolution/correlation.h b/libvips/convolution/correlation.h
index 1111111..2222222 100644
--- a/libvips/convolution/correlation.h
+++ b/libvips/convolution/correlation.h
@@ -35,8 +35,6 @@
 extern "C" {
 #endif /*__cplusplus*/
 
-#include <vips/vector.h>
-
 #define VIPS_TYPE_CORRELATION (vips_correlation_get_type())
 #define VIPS_CORRELATION( obj ) \
 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
diff --git a/libvips/convolution/pconvolution.h b/libvips/convolution/pconvolution.h
index 1111111..2222222 100644
--- a/libvips/convolution/pconvolution.h
+++ b/libvips/convolution/pconvolution.h
@@ -35,8 +35,6 @@
 extern "C" {
 #endif /*__cplusplus*/
 
-#include <vips/vector.h>
-
 #define VIPS_TYPE_CONVOLUTION (vips_convolution_get_type())
 #define VIPS_CONVOLUTION( obj ) \
 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
diff --git a/libvips/deprecated/vips7compat.c b/libvips/deprecated/vips7compat.c
index 1111111..2222222 100644
--- a/libvips/deprecated/vips7compat.c
+++ b/libvips/deprecated/vips7compat.c
@@ -49,7 +49,6 @@
 #include <vips/vips7compat.h>
 #include <vips/internal.h>
 #include <vips/debug.h>
-#include <vips/vector.h>
 #include <vips/transform.h>
 
 /* Split filename into name / mode components. name and mode should both be
@@ -961,47 +960,6 @@ im__bandalike( const char *domain,
 	return( 0 );
 }
 
-VipsVector *
-im__init_program( VipsVector *vectors[IM_BANDFMT_LAST], 
-	VipsBandFmt format_table[IM_BANDFMT_LAST], VipsBandFmt fmt )
-{
-	int isize = im__sizeof_bandfmt[fmt];
-	int osize = im__sizeof_bandfmt[format_table[fmt]];
-
-	VipsVector *v;
-
-	v = vips_vector_new( "binary arith", osize );
-
-	vips_vector_source_name( v, "s1", isize );
-	vips_vector_source_name( v, "s2", isize );
-	vips_vector_temporary( v, "t1", osize );
-	vips_vector_temporary( v, "t2", osize );
-
-	vectors[fmt] = v;
-
-	return( v );
-}
-
-void
-im__compile_programs( VipsVector *vectors[IM_BANDFMT_LAST] )
-{
-	int fmt;
-
-	for( fmt = 0; fmt < IM_BANDFMT_LAST; fmt++ ) {
-		if( vectors[fmt] &&
-			!vips_vector_compile( vectors[fmt] ) )
-			IM_FREEF( vips_vector_free, vectors[fmt] );
-	}
-
-#ifdef DEBUG
-	printf( "im__compile_programs: " );
-	for( fmt = 0; fmt < IM_BANDFMT_LAST; fmt++ ) 
-		if( vectors[fmt] )
-			printf( "%s ", im_BandFmt2char( fmt ) );
-	printf( "\n" );
-#endif /*DEBUG*/
-}
-
 int 
 im_add( IMAGE *in1, IMAGE *in2, IMAGE *out )
 {
diff --git a/libvips/freqfilt/pfreqfilt.h b/libvips/freqfilt/pfreqfilt.h
index 1111111..2222222 100644
--- a/libvips/freqfilt/pfreqfilt.h
+++ b/libvips/freqfilt/pfreqfilt.h
@@ -35,8 +35,6 @@
 extern "C" {
 #endif /*__cplusplus*/
 
-#include <vips/vector.h>
-
 #define VIPS_TYPE_FREQFILT (vips_freqfilt_get_type())
 #define VIPS_FREQFILT( obj ) \
 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
diff --git a/libvips/histogram/hist_unary.h b/libvips/histogram/hist_unary.h
index 1111111..2222222 100644
--- a/libvips/histogram/hist_unary.h
+++ b/libvips/histogram/hist_unary.h
@@ -35,8 +35,6 @@
 extern "C" {
 #endif /*__cplusplus*/
 
-#include <vips/vector.h>
-
 #define VIPS_TYPE_HIST_UNARY (vips_hist_unary_get_type())
 #define VIPS_HIST_UNARY( obj ) \
 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
diff --git a/libvips/histogram/phistogram.h b/libvips/histogram/phistogram.h
index 1111111..2222222 100644
--- a/libvips/histogram/phistogram.h
+++ b/libvips/histogram/phistogram.h
@@ -37,8 +37,6 @@
 extern "C" {
 #endif /*__cplusplus*/
 
-#include <vips/vector.h>
-
 #define VIPS_TYPE_HISTOGRAM (vips_histogram_get_type())
 #define VIPS_HISTOGRAM( obj ) \
 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
diff --git a/libvips/include/vips/Makefile.am b/libvips/include/vips/Makefile.am
index 1111111..2222222 100644
--- a/libvips/include/vips/Makefile.am
+++ b/libvips/include/vips/Makefile.am
@@ -43,7 +43,6 @@ pkginclude_HEADERS = \
 	thread.h \
 	transform.h \
 	util.h \
-	vector.h \
 	vips7compat.h \
 	vips.h
 
diff --git a/libvips/include/vips/meson.build b/libvips/include/vips/meson.build
index 1111111..2222222 100644
--- a/libvips/include/vips/meson.build
+++ b/libvips/include/vips/meson.build
@@ -13,7 +13,6 @@ public_other_headers = files(
     'threadpool.h',
     'transform.h',
     'util.h',
-    'vector.h',
 )
 
 public_deprecated_headers = files(
diff --git a/libvips/include/vips/vector.h b/libvips/include/vips/vector.h
deleted file mode 100644
index 1111111..00000000
--- a/libvips/include/vips/vector.h
+++ /dev/null
@@ -1,183 +0,0 @@
-/* helper stuff for Orc
- *
- * 29/10/10
- *	- from im_dilate hackery
- */
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-#ifndef VIPS_VECTOR_H
-#define VIPS_VECTOR_H
-
-/* If we are building with -fcf-protection (run-time checking of
- * indirect jumps) then Orc won't work. Make sure it's off.
- *
- * https://gcc.gnu.org/onlinedocs/gcc/\
- * 	Instrumentation-Options.html#index-fcf-protection
- * https://gitlab.freedesktop.org/gstreamer/orc/issues/17
- *
- * orc 0.4.30 and later work with cf-protection.
- */
-#ifdef __CET__
-#ifndef HAVE_ORC_CF_PROTECTION
-#undef HAVE_ORC
-#endif
-#endif
-
-#ifdef HAVE_ORC
-#include <orc/orc.h>
-#endif /*HAVE_ORC*/
-
-#ifdef __cplusplus
-extern "C" {
-#endif /*__cplusplus*/
-
-#define VIPS_VECTOR_SOURCE_MAX (10)
-
-/* An Orc program. 
- */
-typedef struct {
-	/* Handy for debugging.
-	 */
-	const char *name;
-	char *unique_name;
-
-	/* How many resources we've used so far in this codegen. 
-	 */
-	int n_temp;
-	int n_scanline;
-	int n_source;
-	int n_destination;
-	int n_constant;
-	int n_parameter;
-	int n_instruction;
-
-	/* The scanline sources, and for each variable, the associated line.
-	 * "sl0" onwards.
-	 */
-	int sl[VIPS_VECTOR_SOURCE_MAX];
-	int line[VIPS_VECTOR_SOURCE_MAX]; 		
-
-	/* Non-scanline sources, "s1" etc. s[0] is the var for "s1".
-	 */
-	int s[VIPS_VECTOR_SOURCE_MAX];
-
-	/* The destination var.
-	 */
-	int d1;
-
-#ifdef HAVE_ORC
-        /* The code we have generated.
-	 */
-        OrcProgram *program;
-#endif /*HAVE_ORC*/
-
-	/* Compiled successfully.
-	 */
-	gboolean compiled;
-} VipsVector;
-
-/* An executor.
- */
-typedef struct {
-#ifdef HAVE_ORC
-	OrcExecutor executor;
-#endif /*HAVE_ORC*/
-
-	VipsVector *vector;
-} VipsExecutor;
-
-/* Set from the command-line.
- */
-extern gboolean vips__vector_enabled;
-
-VIPS_API
-void vips_vector_init( void );
-VIPS_API
-gboolean vips_vector_isenabled( void );
-VIPS_API
-void vips_vector_set_enabled( gboolean enabled );
-
-VIPS_API
-void vips_vector_free( VipsVector *vector );
-VIPS_API
-VipsVector *vips_vector_new( const char *name, int dsize );
-
-VIPS_API
-void vips_vector_constant( VipsVector *vector, 
-	char *name, int value, int size );
-VIPS_API
-void vips_vector_source_scanline( VipsVector *vector, 
-	char *name, int line, int size );
-VIPS_API
-int vips_vector_source_name( VipsVector *vector, const char *name, int size );
-VIPS_API
-void vips_vector_temporary( VipsVector *vector, const char *name, int size );
-VIPS_API
-int vips_vector_parameter( VipsVector *vector, const char *name, int size );
-VIPS_API
-int vips_vector_destination( VipsVector *vector, const char *name, int size );
-VIPS_API
-void vips_vector_asm2( VipsVector *vector, 
-	const char *op, const char *a, const char *b );
-VIPS_API
-void vips_vector_asm3( VipsVector *vector, 
-	const char *op, const char *a, const char *b, const char *c );
-VIPS_API
-gboolean vips_vector_full( VipsVector *vector );
-
-VIPS_API
-gboolean vips_vector_compile( VipsVector *vector );
-
-VIPS_API
-void vips_vector_print( VipsVector *vector );
-
-VIPS_API
-void vips_executor_set_program( VipsExecutor *executor, 
-	VipsVector *vector, int n );
-VIPS_API
-void vips_executor_set_scanline( VipsExecutor *executor, 
-	VipsRegion *ir, int x, int y );
-VIPS_API
-void vips_executor_set_destination( VipsExecutor *executor, void *value );
-VIPS_API
-void vips_executor_set_parameter( VipsExecutor *executor, int var, int value );
-VIPS_API
-void vips_executor_set_array( VipsExecutor *executor, int var, void *value );
-
-VIPS_API
-void vips_executor_run( VipsExecutor *executor ); 
-
-VIPS_API
-void vips_vector_to_fixed_point( double *in, int *out, int n, int scale );
-
-#ifdef __cplusplus
-}
-#endif /*__cplusplus*/
-
-#endif /*VIPS_VECTOR_H*/
diff --git a/libvips/iofuncs/Makefile.am b/libvips/iofuncs/Makefile.am
index 1111111..2222222 100644
--- a/libvips/iofuncs/Makefile.am
+++ b/libvips/iofuncs/Makefile.am
@@ -39,7 +39,6 @@ libiofuncs_la_SOURCES = \
 	init.c \
 	buf.c \
 	window.c \
-	vector.c \
 	system.c \
 	buffer.c 
 
diff --git a/libvips/iofuncs/init.c b/libvips/iofuncs/init.c
index 1111111..2222222 100644
--- a/libvips/iofuncs/init.c
+++ b/libvips/iofuncs/init.c
@@ -108,7 +108,6 @@
 #include <vips/vips.h>
 #include <vips/thread.h>
 #include <vips/internal.h>
-#include <vips/vector.h>
 
 #if ENABLE_DEPRECATED
 #include <vips/vips7compat.h>
@@ -639,10 +638,6 @@ vips_init( const char *argv0 )
 #endif /*ENABLE_DEPRECATED*/
 #endif /*ENABLE_MODULES*/
 
-	/* Get the run-time compiler going.
-	 */
-	vips_vector_init();
-
 #ifdef HAVE_GSF
 	/* Use this for structured file write.
 	 */
@@ -904,9 +899,6 @@ static GOptionEntry option_entries[] = {
 	{ "vips-disc-threshold", 0, 0, 
 		G_OPTION_ARG_STRING, &vips__disc_threshold, 
 		N_( "images larger than N are decompressed to disc" ), "N" },
-	{ "vips-novector", 0, G_OPTION_FLAG_REVERSE, 
-		G_OPTION_ARG_NONE, &vips__vector_enabled, 
-		N_( "disable vectorised versions of operations" ), NULL },
 	{ "vips-cache-max", 0, 0, 
 		G_OPTION_ARG_CALLBACK, (gpointer) &vips_cache_max_cb,
 		N_( "cache at most N operations" ), "N" },
diff --git a/libvips/iofuncs/meson.build b/libvips/iofuncs/meson.build
index 1111111..2222222 100644
--- a/libvips/iofuncs/meson.build
+++ b/libvips/iofuncs/meson.build
@@ -33,7 +33,6 @@ iofuncs_sources = files(
     'init.c',
     'buf.c',
     'window.c',
-    'vector.c',
     'system.c',
     'buffer.c',
 )
diff --git a/libvips/iofuncs/vector.c b/libvips/iofuncs/vector.c
deleted file mode 100644
index 1111111..00000000
--- a/libvips/iofuncs/vector.c
+++ /dev/null
@@ -1,612 +0,0 @@
-/* helper functions for Orc
- *
- * 29/10/10
- * 	- from morph hacking
- */
-
-/*
-
-    This file is part of VIPS.
-    
-    VIPS is free software; you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA
-
- */
-
-/*
-
-    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
-
- */
-
-/* 
-
- 	TODO
-
-	- would setting params by index rather than name be any quicker?
-
- */
-
-/* Verbose messages from Orc (or use ORC_DEBUG=99 on the command-line).
-#define DEBUG_ORC
- */
-
-/*
-#define DEBUG
- */
-
-/* Trace all orc calls, handy for debugging.
-#define DEBUG_TRACE
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif /*HAVE_CONFIG_H*/
-
-#include <glib/gi18n-lib.h>
-
-#include <stdlib.h>
-
-#include <vips/vips.h>
-#include <vips/vector.h>
-#include <vips/internal.h>
-#include <vips/thread.h>
-
-/* Cleared by the command-line --vips-novector switch and the VIPS_NOVECTOR env
- * var.
- */
-gboolean vips__vector_enabled = TRUE;
-
-static void
-vips_vector_error( VipsVector *vector )
-{
-#ifdef HAVE_ORC
-#ifdef HAVE_ORC_PROGRAM_GET_ERROR
-	if( vector->program )
-		g_warning( "orc error: %s", 
-			orc_program_get_error( vector->program ) ); 
-#endif /*HAVE_ORC_PROGRAM_GET_ERROR*/
-#endif /*HAVE_ORC*/
-}
-
-void 
-vips_vector_init( void )
-{
-#ifdef HAVE_ORC
-#ifdef DEBUG_TRACE
-	printf( "orc_init();\n" );
-#endif /*DEBUG_TRACE*/
-	orc_init();
-
-#ifdef DEBUG_ORC
-	/* You can also do ORC_DEBUG=99 at the command-line.
-	 */
-#ifdef DEBUG_TRACE
-	printf( "orc_debug_set_level( 99 );\n" ); 
-#endif /*DEBUG_TRACE*/
-	orc_debug_set_level( 99 );
-#endif /*DEBUG_ORC*/
-
-	/* Look for the environment variable VIPS_NOVECTOR and use that to turn
-	 * off as well.
-	 */
-	if( g_getenv( "VIPS_NOVECTOR" )
-#if ENABLE_DEPRECATED
-		|| g_getenv( "IM_NOVECTOR" )
-#endif
-	)
-		vips__vector_enabled = FALSE;
-
-#endif /*HAVE_ORC*/
-}
-
-gboolean 
-vips_vector_isenabled( void )
-{
-#ifdef HAVE_ORC
-	return( vips__vector_enabled );
-#else /*!HAVE_ORC*/
-	return( FALSE );
-#endif /*HAVE_ORC*/
-}
-
-void 
-vips_vector_set_enabled( gboolean enabled )
-{
-	vips__vector_enabled = enabled;
-}
-
-void
-vips_vector_free( VipsVector *vector )
-{
-#ifdef HAVE_ORC
-	/* orc-0.4.19 will crash if you free programs. Update your orc, or
-	 * comment out this line. 
-	 *
-	 * See https://bugzilla.gnome.org/show_bug.cgi?id=731227
-	 *
-	 * orc does not set any version variables so we can't disable this
-	 * free automatically.
-	 */
-#ifdef DEBUG_TRACE
-	printf( "orc_program_free( %s );\n", vector->unique_name ); 
-	printf( "%s = NULL;\n", vector->unique_name ); 
-#endif /*DEBUG_TRACE*/
-	VIPS_FREEF( orc_program_free, vector->program );
-#endif /*HAVE_ORC*/
-	VIPS_FREE( vector->unique_name );
-	VIPS_FREE( vector );
-}
-
-VipsVector *
-vips_vector_new( const char *name, int dsize )
-{
-	static int vector_number = 0;
-
-	VipsVector *vector;
-	int i;
-
-	if( !(vector = VIPS_NEW( NULL, VipsVector )) )
-		return( NULL );
-	vector->name = name;
-	vector->unique_name = g_strdup_printf( "p[%d]", vector_number++ );
-	vector->n_temp = 0;
-	vector->n_scanline = 0;
-	vector->n_source = 0;
-	vector->n_destination = 0;
-	vector->n_constant = 0;
-	vector->n_parameter = 0;
-	vector->n_instruction = 0;
-
-	for( i = 0; i < VIPS_VECTOR_SOURCE_MAX; i++ ) {
-		vector->s[i] = -1;
-		vector->sl[i] = -1;
-	}
-
-	vector->d1 = -1;
-
-	vector->compiled = FALSE;
-
-#ifdef HAVE_ORC
-	vector->program = orc_program_new();
-#ifdef DEBUG_TRACE
-	printf( "%s = orc_program_new();\n", vector->unique_name );
-#endif /*DEBUG_TRACE*/
-#endif /*HAVE_ORC*/
-
-	/* We always make d1, our callers make either a single point source, or
-	 * for area ops, a set of scanlines.
-	 *
-	 * Don't check error return. orc uses 0 to mean error, but the first
-	 * var you create will have id 0 :-( The first var is unlikely to fail
-	 * anyway. 
-	 */
-	vector->d1 = vips_vector_destination( vector, "d1", dsize ); 
-
-	return( vector );
-}
-
-void 
-vips_vector_asm2( VipsVector *vector, 
-	const char *op, const char *a, const char *b )
-{
-	vector->n_instruction += 1;
-
-#ifdef DEBUG
-	 printf( "  %s %s %s\n", op, a, b );
-#endif /*DEBUG*/
-
-#ifdef HAVE_ORC
-#ifdef DEBUG_TRACE
-	printf( "orc_program_append_ds_str( %s, \"%s\", \"%s\", \"%s\" );\n",
-		vector->unique_name, op, a, b ); 
-#endif /*DEBUG_TRACE*/
-	 orc_program_append_ds_str( vector->program, op, a, b );
-#endif /*HAVE_ORC*/
-}
-
-void 
-vips_vector_asm3( VipsVector *vector, 
-	const char *op, const char *a, const char *b, const char *c )
-{
-	vector->n_instruction += 1;
-
-#ifdef DEBUG
-	 printf( "  %s %s %s %s\n", op, a, b, c );
-#endif /*DEBUG*/
-
-#ifdef HAVE_ORC
-#ifdef DEBUG_TRACE
-	printf( "orc_program_append_str( %s, \"%s\", "
-		"\"%s\", \"%s\", \"%s\" );\n",
-		vector->unique_name, op, a, b, c ); 
-#endif /*DEBUG_TRACE*/
-	 orc_program_append_str( vector->program, op, a, b, c );
-#endif /*HAVE_ORC*/
-}
-
-void
-vips_vector_constant( VipsVector *vector, char *name, int value, int size )
-{
-#ifdef HAVE_ORC
-	char *sname;
-
-	if( size == 1 )
-		sname = "b";
-	else if( size == 2 )
-		sname = "w";
-	else if( size == 4 )
-		sname = "l";
-	else {
-		printf( "vips_vector_constant: bad constant size\n" );
-
-		/* Not really correct, heh.
-		 */
-		sname = "x";
-	}
-
-	if( value > 0 )
-		vips_snprintf( name, 256, "c%d%s", value, sname );
-	else
-		vips_snprintf( name, 256, "cm%d%s", -value, sname );
-
-	if( orc_program_find_var_by_name( vector->program, name ) == -1 ) {
-#ifdef DEBUG_TRACE
-		printf( "orc_program_add_constant( %s, %d, %d, \"%s\" );\n", 
-			vector->unique_name, size, value, name ); 
-#endif /*DEBUG_TRACE*/
-		if( !orc_program_add_constant( vector->program, 
-			size, value, name ) )
-			vips_vector_error( vector );
-		vector->n_constant += 1;
-	}
-#endif /*HAVE_ORC*/
-}
-
-void
-vips_vector_source_scanline( VipsVector *vector, 
-	char *name, int line, int size )
-{
-#ifdef HAVE_ORC
-	vips_snprintf( name, 256, "sl%d", line );
-
-	if( orc_program_find_var_by_name( vector->program, name ) == -1 ) {
-		int var;
-
-		if( !(var = orc_program_add_source( vector->program, 
-			size, name )) ) 
-			vips_vector_error( vector );
-#ifdef DEBUG_TRACE
-		printf( "orc_program_add_source( %s, %d, \"%s\" );\n",
-			vector->unique_name, size, name );
-#endif /*DEBUG_TRACE*/
-		vector->sl[vector->n_scanline] = var;
-		vector->line[vector->n_scanline] = line;
-		vector->n_scanline += 1;
-	}
-#endif /*HAVE_ORC*/
-}
-
-int
-vips_vector_source_name( VipsVector *vector, const char *name, int size )
-{
-	int var;
-
-#ifdef HAVE_ORC
-	g_assert( orc_program_find_var_by_name( vector->program, name ) == -1 );
-
-	if( !(var = orc_program_add_source( vector->program, size, name )) )
-		vips_vector_error( vector ); 
-	vector->s[vector->n_source] = var;
-#ifdef DEBUG_TRACE
-	printf( "orc_program_add_source( %s, %d, \"%s\" );\n", 
-		vector->unique_name, size, name );
-#endif /*DEBUG_TRACE*/
-	vector->n_source += 1;
-#else /*!HAVE_ORC*/
-	var = -1;
-#endif /*HAVE_ORC*/
-
-	return( var );
-}
-
-void
-vips_vector_temporary( VipsVector *vector, const char *name, int size )
-{
-#ifdef HAVE_ORC
-	g_assert( orc_program_find_var_by_name( vector->program, name ) == -1 );
-
-	if( !orc_program_add_temporary( vector->program, size, name ) )
-		vips_vector_error( vector ); 
-
-#ifdef DEBUG_TRACE
-	printf( "orc_program_add_temporary( %s, %d, \"%s\" );\n",
-		vector->unique_name, size, name );
-#endif /*DEBUG_TRACE*/
-	vector->n_temp += 1;
-#endif /*HAVE_ORC*/
-}
-
-int
-vips_vector_parameter( VipsVector *vector, const char *name, int size )
-{
-	int var;
-
-#ifdef HAVE_ORC
-	g_assert( orc_program_find_var_by_name( vector->program, name ) == -1 );
-
-	var = orc_program_add_parameter( vector->program, size, name );
-	if( !var )
-		vips_vector_error( vector ); 
-
-#ifdef DEBUG_TRACE
-	printf( "orc_program_add_parameter( %s, %d, \"%s\" );\n",
-		vector->unique_name, size, name );
-#endif /*DEBUG_TRACE*/
-	vector->n_parameter += 1;
-#else /*!HAVE_ORC*/
-	var = -1;
-#endif /*HAVE_ORC*/
-
-	return ( var ); 
-}
-
-int
-vips_vector_destination( VipsVector *vector, const char *name, int size )
-{
-	int var;
-
-#ifdef HAVE_ORC
-	g_assert( orc_program_find_var_by_name( vector->program, name ) == -1 );
-
-	var = orc_program_add_destination( vector->program, size, name );
-#ifdef DEBUG_TRACE
-	printf( "orc_program_add_destination( %d, \"%s\" );\n",
-		size, name );
-#endif /*DEBUG_TRACE*/
-	vector->n_destination += 1;
-#else /*!HAVE_ORC*/
-	var = -1;
-#endif /*HAVE_ORC*/
-
-	return( var ); 
-}
-
-gboolean
-vips_vector_full( VipsVector *vector )
-{
-	/* Many orcs don't have ORC_MAX_CONST_VARS etc., stick to our own
-	 * constants for now.
-	 */
-
-	/* We can need a max of 2 constants plus one source per
-	 * coefficient, so stop if we're sure we don't have enough.
-	 */
-	if( vector->n_constant + 2 > 8 )
-		return( TRUE );
-
-	/* You can have 8 source, and d1 counts as one of them, so +1
-	 * there.
-	 */
-	if( vector->n_source + vector->n_scanline + 1 > 7 )
-		return( TRUE );
-
-	/* Need to leave some space, so 1 spare. 
-	 */
-	if( vector->n_parameter > 7 )
-		return( TRUE );
-
-	/* After signalling full, some operations will add up to 4 more 
-	 * instructions as they finish up. Leave a margin.
-	 */
-	if( vector->n_instruction + 10 > 50 )
-		return( TRUE );
-
-	return( FALSE );
-}
-
-gboolean
-vips_vector_compile( VipsVector *vector )
-{
-#ifdef HAVE_ORC
-	OrcCompileResult result;
-
-	/* Some orcs seem to be unstable with many compilers active at once.
-	 */
-	g_mutex_lock( vips__global_lock );
-	result = orc_program_compile( vector->program );
-	g_mutex_unlock( vips__global_lock );
-
-#ifdef DEBUG_TRACE
-	printf( "orc_program_compile( %s );\n", vector->unique_name );
-#endif /*DEBUG_TRACE*/
-	if( !ORC_COMPILE_RESULT_IS_SUCCESSFUL( result ) ) {
-#ifdef DEBUG
-		printf( "*** error compiling %s\n", vector->name );
-#endif /*DEBUG*/
-
-		return( FALSE );
-	}
-
-	vector->compiled = TRUE;
-#endif /*HAVE_ORC*/
-
-	return( TRUE );
-}
-
-void
-vips_vector_print( VipsVector *vector )
-{
-	int i;
-
-	printf( "%s: ", vector->name );
-	if( vector->compiled )
-		printf( "successfully compiled\n" );
-	else
-		printf( "not compiled\n" );
-	printf( "  n_scanline = %d\n", vector->n_scanline );
-	for( i = 0; i < vector->n_scanline; i++ )
-		printf( "        var %d = line %d\n", 
-			vector->sl[i], vector->line[i] ); 
-	printf( "  n_source = %d\n", vector->n_source );
-	for( i = 0; i < vector->n_source; i++ )
-		printf( "        var %d\n", vector->s[i] );
-	printf( "  n_parameter = %d\n", vector->n_parameter );
-	printf( "  n_destination = %d\n", vector->n_destination );
-	printf( "  n_constant = %d\n", vector->n_constant );
-	printf( "  n_temp = %d\n", vector->n_temp );
-	printf( "  n_instruction = %d\n", vector->n_instruction );
-}
-
-void
-vips_executor_set_program( VipsExecutor *executor, VipsVector *vector, int n )
-{
-#ifdef HAVE_ORC
-	executor->vector = vector;
-
-	orc_executor_set_program( &executor->executor, vector->program );
-	orc_executor_set_n( &executor->executor, n );
-#endif /*HAVE_ORC*/
-}
-
-void
-vips_executor_set_array( VipsExecutor *executor, int var, void *value )
-{
-#ifdef HAVE_ORC
-	if( var != -1 )  
-		orc_executor_set_array( &executor->executor, var, value );
-#endif /*HAVE_ORC*/
-}
-
-void
-vips_executor_set_parameter( VipsExecutor *executor, int var, int value )
-{
-#ifdef HAVE_ORC
-	if( var != -1 )  
-		orc_executor_set_param( &executor->executor, var, value );
-#endif /*HAVE_ORC*/
-}
-
-void
-vips_executor_set_scanline( VipsExecutor *executor, 
-	VipsRegion *ir, int x, int y )
-{
-	VipsVector *vector = executor->vector;
-	VipsPel *base = VIPS_REGION_ADDR( ir, x, y );
-	int lsk = VIPS_REGION_LSKIP( ir );
-
-	int i;
-
-	for( i = 0; i < vector->n_scanline; i++ ) 
-		vips_executor_set_array( executor, 
-			vector->sl[i], base + vector->line[i] * lsk );
-}
-
-void
-vips_executor_set_destination( VipsExecutor *executor, void *value )
-{
-	VipsVector *vector = executor->vector;
-
-	vips_executor_set_array( executor, vector->d1, value );
-}
-
-void
-vips_executor_run( VipsExecutor *executor )
-{
-#ifdef HAVE_ORC
-	orc_executor_run( &executor->executor );
-#endif /*HAVE_ORC*/
-}
-
-/* Make a fixed-point version of a matrix. Each 
- * out[i] = rint(in[i] * adj_scale), where adj_scale is selected so that 
- * sum(out) = sum(in) * scale.
- *
- * Because of the vagaries of rint(), we can't just calc this, we have to
- * iterate and converge on the best value for adj_scale.
- */
-void
-vips_vector_to_fixed_point( double *in, int *out, int n, int scale )
-{
-	double fsum;
-	int i;
-	int target;
-	int sum;
-	double high;
-	double low;
-	double guess;
-
-	fsum = 0.0;
-	for( i = 0; i < n; i++ )
-		fsum += in[i];
-	target = VIPS_RINT( fsum * scale );
-
-	/* As we rint() each scale element, we can get up to 0.5 error.
-	 * Therefore, by the end of the mask, we can be off by up to n/2. Our
-	 * high and low guesses are therefore n/2 either side of the obvious
-	 * answer.
-	 */
-	high = scale + (n + 1) / 2;
-	low = scale - (n + 1) / 2;
-
-	do {
-		guess = (high + low) / 2.0;
-
-		for( i = 0; i < n; i++ ) 
-			out[i] = VIPS_RINT( in[i] * guess );
-
-		sum = 0;
-		for( i = 0; i < n; i++ )
-			sum += out[i];
-
-		if( sum == target )
-			break;
-		if( sum < target )
-			low = guess;
-		if( sum > target )
-			high = guess;
-
-	/* This will typically produce about 5 iterations.
-	 */
-	} while( high - low > 0.01 );
-
-	if( sum != target ) {
-		/* Spread the error out thinly over the whole array. For
-		 * example, consider the matrix:
-		 *
-		 * 	3 3 9 0
-		 *	1 1 1
-		 *	1 1 1
-		 *	1 1 1
-		 *
-		 * being converted with scale = 64 (convi does this). We want
-		 * to generate a mix of 7s and 8s. 
-		 */
-		int each_error = (target - sum) / n;
-		int extra_error = (target - sum) % n;
-
-		/* To share the residual error, we add or subtract 1 from the
-		 * first abs(extra_error) elements.
-		 */
-		int direction = extra_error > 0 ? 1 : -1;
-		int n_elements = VIPS_ABS( extra_error );
-
-		for( i = 0; i < n; i++ )
-			out[i] += each_error;
-
-		for( i = 0; i < n_elements; i++ )
-			out[i] += direction;
-	}
-}
diff --git a/libvips/morphology/morph.c b/libvips/morphology/morph.c
index 1111111..2222222 100644
--- a/libvips/morphology/morph.c
+++ b/libvips/morphology/morph.c
@@ -65,31 +65,11 @@
 #include <limits.h>
 
 #include <vips/vips.h>
-#include <vips/vector.h>
 #include <vips/debug.h>
 #include <vips/internal.h>
 
 #include "pmorphology.h"
 
-/* We can't run more than this many passes. Larger than this and we
- * fall back to C.
- * TODO: Could this be raised to 20? Just like convi.
- */
-#define MAX_PASS (10)
-
-/* A pass with a vector. 
- */
-typedef struct {
-	int first;		/* The index of the first mask coff we use */
-	int last;		/* The index of the last mask coff we use */
-
-	int r;			/* Set previous result in this var */
-
-	/* The code we generate for this section of this mask. 
-	 */
-	VipsVector *vector;
-} Pass;
-
 /** 
  * VipsOperationMorphology:
  * @VIPS_OPERATION_MORPHOLOGY_ERODE: true if all set
@@ -114,11 +94,6 @@ typedef struct {
 	int n_point;		/* w * h for our matrix */
 
 	int *coeff;			/* Mask coefficients */
-
-	/* The passes we generate for this mask.
-	 */
-	int n_pass;	
-	Pass pass[MAX_PASS];
 } VipsMorph;
 
 typedef VipsMorphologyClass VipsMorphClass;
@@ -137,40 +112,8 @@ typedef struct {
 	int cs;			/* ... and number we check for clear */
 
 	int last_bpl;		/* Avoid recalcing offsets, if we can */
-
-	/* In vector mode we need a pair of intermediate buffers to keep the 
-	 * results of each pass in.
-	 */
-	void *t1;
-	void *t2;
 } VipsMorphSequence;
 
-static void
-vips_morph_compile_free( VipsMorph *morph )
-{
-	int i;
-
-	for( i = 0; i < morph->n_pass; i++ )
-		VIPS_FREEF( vips_vector_free, morph->pass[i].vector );
-	morph->n_pass = 0;
-}
-
-static void
-vips_morph_dispose( GObject *gobject )
-{
-	VipsMorph *morph = (VipsMorph *) gobject;
-
-#ifdef DEBUG
-	printf( "vips_morph_dispose: " );
-	vips_object_print_name( VIPS_OBJECT( gobject ) );
-	printf( "\n" );
-#endif /*DEBUG*/
-
-	vips_morph_compile_free( morph ); 
-
-	G_OBJECT_CLASS( vips_morph_parent_class )->dispose( gobject );
-}
-
 /* Free a sequence value.
  */
 static int
@@ -179,8 +122,6 @@ vips_morph_stop( void *vseq, void *a, void *b )
 	VipsMorphSequence *seq = (VipsMorphSequence *) vseq;
 
 	VIPS_UNREF( seq->ir );
-	VIPS_FREE( seq->t1 );
-	VIPS_FREE( seq->t2 );
 
 	return( 0 );
 }
@@ -207,13 +148,9 @@ vips_morph_start( VipsImage *out, void *a, void *b )
 	seq->coff = NULL;
 	seq->cs = 0;
 	seq->last_bpl = -1;
-	seq->t1 = NULL;
-	seq->t2 = NULL;
 
 	seq->ir = vips_region_new( in );
 
-	/* C mode.
-	 */
 	seq->soff = VIPS_ARRAY( out, morph->n_point, int );
 	seq->coff = VIPS_ARRAY( out, morph->n_point, int );
 
@@ -223,184 +160,9 @@ vips_morph_start( VipsImage *out, void *a, void *b )
 		return( NULL );
 	}
 
-	/* Vector mode.
-	 */
-	if( morph->n_pass ) {
-		seq->t1 = VIPS_ARRAY( NULL, 
-			VIPS_IMAGE_N_ELEMENTS( in ), VipsPel );
-		seq->t2 = VIPS_ARRAY( NULL, 
-			VIPS_IMAGE_N_ELEMENTS( in ), VipsPel );
-
-		if( !seq->t1 || 
-			!seq->t2 ) {
-			vips_morph_stop( seq, in, morph );
-			return( NULL );
-		}
-	}
-
 	return( seq );
 }
 
-#define TEMP( N, S ) vips_vector_temporary( v, N, S )
-#define SCANLINE( N, P, S ) vips_vector_source_scanline( v, N, P, S )
-#define CONST( N, V, S ) vips_vector_constant( v, N, V, S )
-#define ASM2( OP, A, B ) vips_vector_asm2( v, OP, A, B )
-#define ASM3( OP, A, B, C ) vips_vector_asm3( v, OP, A, B, C )
-
-/* Generate code for a section of the mask. first is the index we start
- * at, we set last to the index of the last one we use before we run 
- * out of intermediates / constants / parameters / sources or mask
- * coefficients.
- *
- * 0 for success, -1 on error.
- */
-static int
-vips_morph_compile_section( VipsMorph *morph, Pass *pass, gboolean first_pass )
-{
-	VipsMorphology *morphology = (VipsMorphology *) morph;
-	VipsImage *M = morph->M;
-
-	VipsVector *v;
-	char offset[256];
-	char source[256];
-	char zero[256];
-	char one[256];
-	int i;
-
-	pass->vector = v = vips_vector_new( "morph", 1 );
-
-	/* The value we fetch from the image, the accumulated sum.
-	 */
-	TEMP( "value", 1 );
-	TEMP( "sum", 1 );
-
-	CONST( zero, 0, 1 );
-	CONST( one, 255, 1 );
-
-	/* Init the sum. If this is the first pass, it's a constant. If this
-	 * is a later pass, we have to init the sum from the result 
-	 * of the previous pass. 
-	 */
-	if( first_pass ) {
-		if( morph->morph == VIPS_OPERATION_MORPHOLOGY_DILATE )
-			ASM2( "copyb", "sum", zero );
-		else
-			ASM2( "copyb", "sum", one );
-	}
-	else {
-		/* "r" is the result of the previous pass. 
-		 */
-		pass->r = vips_vector_source_name( v, "r", 1 );
-		ASM2( "loadb", "sum", "r" );
-	}
-
-	for( i = pass->first; i < morph->n_point; i++ ) {
-		int x = i % M->Xsize;
-		int y = i / M->Xsize;
-
-		/* Exclude don't-care elements.
-		 */
-		if( morph->coeff[i] == 128 )
-			continue;
-
-		/* The source. sl0 is the first scanline in the mask.
-		 */
-		SCANLINE( source, y, 1 );
-
-		/* The offset, only for non-first-columns though.
-		 */
-		if( x > 0 ) {
-			CONST( offset, morphology->in->Bands * x, 1 );
-			ASM3( "loadoffb", "value", source, offset );
-		}
-		else
-			ASM2( "loadb", "value", source );
-
-		/* Join to our sum. If the mask element is zero, we have to
-		 * add an extra negate.
-		 */
-		if( morph->morph == VIPS_OPERATION_MORPHOLOGY_DILATE ) {
-			if( !morph->coeff[i] ) 
-				ASM3( "xorb", "value", "value", one );
-			ASM3( "orb", "sum", "sum", "value" );
-		}
-		else {
-			if( !morph->coeff[i] ) {
-				/* You'd think we could use andnb, but it
-				 * fails on some machines with some orc
-				 * versions :( 
-				 */
-				ASM3( "xorb", "value", "value", one );
-				ASM3( "andb", "sum", "sum", "value" );
-			}
-			else
-				ASM3( "andb", "sum", "sum", "value" );
-		}
-
-		if( vips_vector_full( v ) )
-			break;
-	}
-
-	pass->last = i;
-
-	ASM2( "copyb", "d1", "sum" );
-
-	if( !vips_vector_compile( v ) ) 
-		return( -1 );
-
-#ifdef DEBUG
-	printf( "done matrix coeffs %d to %d\n", pass->first, pass->last );
-	vips_vector_print( v );
-#endif /*DEBUG*/
-
-	return( 0 );
-}
-
-/* Generate a set of passes.
- */
-static int
-vips_morph_compile( VipsMorph *morph )
-{
-	int i;
-	Pass *pass;
-
-#ifdef DEBUG
-	printf( "vips_morph_compile: generating vector code\n" );
-#endif /*DEBUG*/
-
-	/* Generate passes until we've used up the whole mask.
-	 */
-	for( i = 0;;) {
-		/* Skip any don't-care coefficients at the start of the mask 
-		 * region.
-		 */
-		for( ; i < morph->n_point && morph->coeff[i] == 128; i++ )
-			;
-		if( i == morph->n_point )
-			break;
-
-		/* Allocate space for another pass.
-		 */
-		if( morph->n_pass == MAX_PASS ) 
-			return( -1 );
-		pass = &morph->pass[morph->n_pass];
-		morph->n_pass += 1;
-
-		pass->first = i;
-		pass->last = i;
-		pass->r = -1;
-
-		if( vips_morph_compile_section( morph, pass, morph->n_pass == 1 ) )
-			return( -1 );
-		i = pass->last + 1;
-
-		if( i >= morph->n_point )
-			break;
-	}
-
-	return( 0 );
-}
-
 /* Dilate!
  */
 static int
@@ -620,73 +382,6 @@ vips_erode_gen( VipsRegion *or,
 	return( 0 );
 }
 
-/* The vector codepath.
- */
-static int
-vips_morph_gen_vector( VipsRegion *or, 
-	void *vseq, void *a, void *b, gboolean *stop )
-{
-	VipsMorphSequence *seq = (VipsMorphSequence *) vseq;
-	VipsMorph *morph = (VipsMorph *) b;
-	VipsImage *M = morph->M;
-	VipsRegion *ir = seq->ir;
-	VipsRect *r = &or->valid;
-	int sz = VIPS_REGION_N_ELEMENTS( or );
-
-	VipsRect s;
-	int y, j;
-	VipsExecutor executor[MAX_PASS];
-
-	/* Prepare the section of the input image we need. A little larger
-	 * than the section of the output image we are producing.
-	 */
-	s = *r;
-	s.width += M->Xsize - 1;
-	s.height += M->Ysize - 1;
-	if( vips_region_prepare( ir, &s ) )
-		return( -1 );
-
-#ifdef DEBUG_VERBOSE
-	printf( "vips_morph_gen_vector: preparing %dx%d@%dx%d pixels\n", 
-		s.width, s.height, s.left, s.top );
-#endif /*DEBUG_VERBOSE*/
-
-	for( j = 0; j < morph->n_pass; j++ ) 
-		vips_executor_set_program( &executor[j], 
-			morph->pass[j].vector, sz );
-
-	VIPS_GATE_START( "vips_morph_gen_vector: work" ); 
-
-	for( y = 0; y < r->height; y++ ) { 
-		for( j = 0; j < morph->n_pass; j++ ) {
-			void *d;
-
-			/* The last pass goes to the output image,
-			 * intermediate passes go to t2.
-			 */
-			if( j == morph->n_pass - 1 )
-				d = VIPS_REGION_ADDR( or, r->left, r->top + y );
-			else 
-				d = seq->t2;
-
-			vips_executor_set_scanline( &executor[j], 
-				ir, r->left, r->top + y );
-			vips_executor_set_array( &executor[j],
-				morph->pass[j].r, seq->t1 );
-			vips_executor_set_destination( &executor[j], d );
-			vips_executor_run( &executor[j] );
-
-			VIPS_SWAP( void *, seq->t1, seq->t2 );
-		}
-	}
-
-	VIPS_GATE_STOP( "vips_morph_gen_vector: work" ); 
-
-	VIPS_COUNT_PIXELS( or, "vips_morph_gen_vector" ); 
-
-	return( 0 );
-}
-
 static int
 vips_morph_build( VipsObject *object )
 {
@@ -759,17 +454,6 @@ vips_morph_build( VipsObject *object )
 	generate = morph->morph == VIPS_OPERATION_MORPHOLOGY_DILATE
 		? vips_dilate_gen : vips_erode_gen;
 
-	/* Generate code for this mask / image, if possible.
-	 */
-	if( vips_vector_isenabled() ) {
-		if( !vips_morph_compile( morph ) ) {
-			generate = vips_morph_gen_vector;
-			g_info( "morph: using vector path" ); 
-		}
-		else
-			vips_morph_compile_free( morph );
-	}
-
 	g_object_set( morph, "out", vips_image_new(), NULL ); 
 	if( vips_image_pipelinev( morph->out, 
 		VIPS_DEMAND_STYLE_SMALLTILE, in, NULL ) )
@@ -802,8 +486,6 @@ vips_morph_class_init( VipsMorphClass *class )
 	gobject_class->set_property = vips_object_set_property;
 	gobject_class->get_property = vips_object_get_property;
 
-	gobject_class->dispose = vips_morph_dispose;
-
 	object_class->nickname = "morph";
 	object_class->description = _( "morphology operation" );
 	object_class->build = vips_morph_build;
diff --git a/libvips/morphology/pmorphology.h b/libvips/morphology/pmorphology.h
index 1111111..2222222 100644
--- a/libvips/morphology/pmorphology.h
+++ b/libvips/morphology/pmorphology.h
@@ -35,8 +35,6 @@
 extern "C" {
 #endif /*__cplusplus*/
 
-#include <vips/vector.h>
-
 #define VIPS_TYPE_MORPHOLOGY (vips_morphology_get_type())
 #define VIPS_MORPHOLOGY( obj ) \
 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
diff --git a/libvips/resample/reduceh.cpp b/libvips/resample/reduceh.cpp
index 1111111..2222222 100644
--- a/libvips/resample/reduceh.cpp
+++ b/libvips/resample/reduceh.cpp
@@ -182,7 +182,7 @@ reduceh_unsigned_int_tab( VipsReduceh *reduceh,
 
 	for( int z = 0; z < bands; z++ ) {
 		int sum;
-	       
+
 		sum = reduce_sum<T, int>( in + z, bands, cx, n );
 		sum = unsigned_fixed_round( sum ); 
 		sum = VIPS_CLIP( 0, sum, max_value ); 
@@ -263,8 +263,7 @@ reduceh_signed_int32_tab( VipsReduceh *reduceh,
 		double sum;
 
 		sum = reduce_sum<T, double>( in + z, bands, cx, n );
-		sum = VIPS_CLIP( min_value, sum, max_value ); 
-		out[z] = sum;
+		out[z] = VIPS_CLIP( min_value, sum, max_value );
 	}
 }
 
@@ -292,10 +291,6 @@ reduceh_notab( VipsReduceh *reduceh,
 	}
 }
 
-/* Tried a vector path (see reducev) but it was slower. The vectors for
- * horizontal reduce are just too small to get a useful speedup.
- */
-
 static int
 vips_reduceh_gen( VipsRegion *out_region, void *seq, 
 	void *a, void *b, gboolean *stop )
diff --git a/libvips/resample/reducev.cpp b/libvips/resample/reducev.cpp
index 1111111..2222222 100644
--- a/libvips/resample/reducev.cpp
+++ b/libvips/resample/reducev.cpp
@@ -53,8 +53,6 @@
  */
 
 /*
-#define DEBUG_PIXELS
-#define DEBUG_COMPILE
 #define DEBUG
  */
 
@@ -70,37 +68,10 @@
 #include <vips/vips.h>
 #include <vips/debug.h>
 #include <vips/internal.h>
-#include <vips/vector.h>
 
 #include "presample.h"
 #include "templates.h"
 
-/* We can't run more than this many passes. Larger than this and we
- * fall back to C.
- */
-#define MAX_PASS (10)
-
-/* The number of params we pass for coeffs. Orc limits this rather. 
- */
-#define MAX_PARAM (8)
-
-/* A pass with a vector. 
- */
-typedef struct {
-	int first;		/* The index of the first mask coff we use */
-	int last;		/* The index of the last mask coff we use */
-
-	int r;			/* Set previous result in this var */
-	int d2;			/* Write new temp result here */
-
-	int p[MAX_PARAM];	/* Mask coeffs passed in these */
-	int n_param;
-
-        /* The code we generate for this section of this mask. 
-	 */
-        VipsVector *vector;
-} Pass;
-
 typedef struct _VipsReducev {
 	VipsResample parent_instance;
 
@@ -126,15 +97,6 @@ typedef struct _VipsReducev {
 	int *matrixi[VIPS_TRANSFORM_SCALE + 1];
 	double *matrixf[VIPS_TRANSFORM_SCALE + 1];
 
-	/* And another set for orc: we want 2.6 precision.
-	 */
-	int *matrixo[VIPS_TRANSFORM_SCALE + 1];
-
-	/* The passes we generate for this mask.
-	 */
-	int n_pass;	
-	Pass pass[MAX_PASS];
-
 	/* Deprecated.
 	 */
 	gboolean centre;
@@ -149,249 +111,6 @@ extern "C" {
 G_DEFINE_TYPE( VipsReducev, vips_reducev, VIPS_TYPE_RESAMPLE );
 }
 
-static void
-vips_reducev_finalize( GObject *gobject )
-{
-	VipsReducev *reducev = (VipsReducev *) gobject; 
-
-	for( int i = 0; i < reducev->n_pass; i++ )
-		VIPS_FREEF( vips_vector_free, reducev->pass[i].vector );
-	reducev->n_pass = 0;
-	for( int i = 0; i < VIPS_TRANSFORM_SCALE + 1; i++ ) {
-		VIPS_FREE( reducev->matrixf[i] );
-		VIPS_FREE( reducev->matrixi[i] );
-		VIPS_FREE( reducev->matrixo[i] );
-	}
-
-	G_OBJECT_CLASS( vips_reducev_parent_class )->finalize( gobject );
-}
-
-#define TEMP( N, S ) vips_vector_temporary( v, (char *) N, S )
-#define PARAM( N, S ) vips_vector_parameter( v, (char *) N, S )
-#define SCANLINE( N, P, S ) vips_vector_source_scanline( v, (char *) N, P, S )
-#define CONST( N, V, S ) vips_vector_constant( v, (char *) N, V, S )
-#define ASM2( OP, A, B ) vips_vector_asm2( v, (char *) OP, A, B )
-#define ASM3( OP, A, B, C ) vips_vector_asm3( v, (char *) OP, A, B, C )
-
-/* Generate code for a section of the mask. first is the index we start
- * at, we set last to the index of the last one we use before we run 
- * out of intermediates / constants / parameters / sources or mask
- * coefficients.
- *
- * 0 for success, -1 on error.
- */
-static int
-vips_reducev_compile_section( VipsReducev *reducev, Pass *pass, gboolean first )
-{
-	VipsVector *v;
-	int i;
-
-#ifdef DEBUG_COMPILE
-	printf( "starting pass %d\n", pass->first ); 
-#endif /*DEBUG_COMPILE*/
-
-	pass->vector = v = vips_vector_new( "reducev", 1 );
-
-	/* We have two destinations: the final output image (8-bit) and the
-	 * intermediate buffer if this is not the final pass (16-bit).
-	 */
-	pass->d2 = vips_vector_destination( v, "d2", 2 );
-
-	/* "r" is the array of sums from the previous pass (if any).
-	 */
-	pass->r = vips_vector_source_name( v, "r", 2 );
-
-	/* The value we fetch from the image, the accumulated sum.
-	 */
-	TEMP( "value", 2 );
-	TEMP( "sum", 2 );
-
-	/* Init the sum. If this is the first pass, it's a constant. If this
-	 * is a later pass, we have to init the sum from the result 
-	 * of the previous pass. 
-	 */
-	if( first ) {
-		char c0[256];
-
-		CONST( c0, 0, 2 );
-		ASM2( "loadpw", "sum", c0 );
-	}
-	else 
-		ASM2( "loadw", "sum", "r" );
-
-	for( i = pass->first; i < reducev->n_point; i++ ) {
-		char source[256];
-		char coeff[256];
-
-		SCANLINE( source, i, 1 );
-
-		/* This mask coefficient.
-		 */
-		vips_snprintf( coeff, 256, "p%d", i );
-		pass->p[pass->n_param] = PARAM( coeff, 2 );
-		pass->n_param += 1;
-		if( pass->n_param >= MAX_PARAM )
-			return( -1 );
-
-		/* Mask coefficients are 2.6 bits fixed point. We need to hold
-		 * about -0.5 to 1.0, so -2 to +1.999 is as close as we can
-		 * get. 
-		 *
-		 * We need a signed multiply, so the image pixel needs to
-		 * become a signed 16-bit value. We know only the bottom 8 bits
-		 * of the image and coefficient are interesting, so we can take
-		 * the bottom bits of a 16x16->32 multiply. 
-		 *
-		 * We accumulate the signed 16-bit result in sum.
-		 */
-		ASM2( "convubw", "value", source );
-		ASM3( "mullw", "value", "value", coeff );
-		ASM3( "addssw", "sum", "sum", "value" );
-
-		/* We've used this coeff.
-		 */
-		pass->last = i;
-
-		if( vips_vector_full( v ) )
-			break;
-
-		/* orc 0.4.24 and earlier hate more than about five lines at
-		 * once :( 
-		 */
-		if( i - pass->first > 3 )
-			break;
-	}
-
-	/* If this is the end of the mask, we write the 8-bit result to the
-	 * image, otherwise write the 16-bit intermediate to our temp buffer. 
-	 */
-	if( pass->last >= reducev->n_point - 1 ) {
-		char c32[256];
-		char c6[256];
-		char c0[256];
-		char c255[256];
-
-		CONST( c32, 32, 2 );
-		ASM3( "addw", "sum", "sum", c32 );
-		CONST( c6, 6, 2 );
-		ASM3( "shrsw", "sum", "sum", c6 );
-
-		/* You'd think "convsuswb", convert signed 16-bit to unsigned
-		 * 8-bit with saturation, would be quicker, but it's a lot
-		 * slower.
-		 */
-		CONST( c0, 0, 2 );
-		ASM3( "maxsw", "sum", c0, "sum" ); 
-		CONST( c255, 255, 2 );
-		ASM3( "minsw", "sum", c255, "sum" ); 
-
-		ASM2( "convwb", "d1", "sum" );
-	}
-	else 
-		ASM2( "copyw", "d2", "sum" );
-
-	if( !vips_vector_compile( v ) ) 
-		return( -1 );
-
-#ifdef DEBUG_COMPILE
-	printf( "done coeffs %d to %d\n", pass->first, pass->last );
-	vips_vector_print( v );
-#endif /*DEBUG_COMPILE*/
-
-	return( 0 );
-}
-
-static int
-vips_reducev_compile( VipsReducev *reducev )
-{
-	Pass *pass;
-
-	/* Generate passes until we've used up the whole mask.
-	 */
-	for( int i = 0;; ) {
-		/* Allocate space for another pass.
-		 */
-		if( reducev->n_pass == MAX_PASS ) 
-			return( -1 );
-		pass = &reducev->pass[reducev->n_pass];
-		reducev->n_pass += 1;
-
-		pass->first = i;
-		pass->r = -1;
-		pass->d2 = -1;
-		pass->n_param = 0;
-
-		if( vips_reducev_compile_section( reducev,
-			pass, reducev->n_pass == 1 ) )
-			return( -1 );
-		i = pass->last + 1;
-
-		if( i >= reducev->n_point )
-			break;
-	}
-
-	return( 0 );
-}
-
-/* Our sequence value.
- */
-typedef struct {
-	VipsReducev *reducev;
-	VipsRegion *ir;		/* Input region */
-
-	/* In vector mode we need a pair of intermediate buffers to keep the 
-	 * results of each pass in.
-	 */
-	signed short *t1;
-	signed short *t2;
-} Sequence;
-
-static int
-vips_reducev_stop( void *vseq, void *a, void *b )
-{
-	Sequence *seq = (Sequence *) vseq;
-
-	VIPS_UNREF( seq->ir );
-	VIPS_FREE( seq->t1 );
-	VIPS_FREE( seq->t2 );
-
-	return( 0 );
-}
-
-static void *
-vips_reducev_start( VipsImage *out, void *a, void *b )
-{
-	VipsImage *in = (VipsImage *) a;
-	VipsReducev *reducev = (VipsReducev *) b;
-	int sz = VIPS_IMAGE_N_ELEMENTS( in );
-
-	Sequence *seq;
-
-	if( !(seq = VIPS_NEW( out, Sequence )) )
-		return( NULL );
-
-	/* Init!
-	 */
-	seq->reducev = reducev;
-	seq->ir = NULL;
-	seq->t1 = NULL;
-	seq->t2 = NULL;
-
-	/* Attach region and arrays.
-	 */
-	seq->ir = vips_region_new( in );
-	seq->t1 = VIPS_ARRAY( NULL, sz, signed short );
-	seq->t2 = VIPS_ARRAY( NULL, sz, signed short );
-	if( !seq->ir || 
-		!seq->t1 || 
-		!seq->t2  ) {
-		vips_reducev_stop( seq, NULL, NULL );
-		return( NULL );
-	}
-
-	return( seq );
-}
-
 /* You'd think this would vectorise, but gcc hates mixed types in nested loops
  * :-(
  */
@@ -523,13 +242,12 @@ reducev_notab( VipsReducev *reducev,
 }
 
 static int
-vips_reducev_gen( VipsRegion *out_region, void *vseq, 
+vips_reducev_gen( VipsRegion *out_region, void *seq, 
 	void *a, void *b, gboolean *stop )
 {
 	VipsImage *in = (VipsImage *) a;
 	VipsReducev *reducev = (VipsReducev *) b;
-	Sequence *seq = (Sequence *) vseq;
-	VipsRegion *ir = seq->ir;
+	VipsRegion *ir = (VipsRegion *) seq;
 	VipsRect *r = &out_region->valid;
 
 	/* Double bands for complex.
@@ -639,175 +357,14 @@ vips_reducev_gen( VipsRegion *out_region, void *vseq,
 	return( 0 );
 }
 
-/* Process uchar images with a vector path.
- */
-static int
-vips_reducev_vector_gen( VipsRegion *out_region, void *vseq, 
-	void *a, void *b, gboolean *stop )
-{
-	VipsImage *in = (VipsImage *) a;
-	VipsReducev *reducev = (VipsReducev *) b;
-	Sequence *seq = (Sequence *) vseq;
-	VipsRegion *ir = seq->ir;
-	VipsRect *r = &out_region->valid;
-	int ne = r->width * in->Bands;
-
-	VipsExecutor executor[MAX_PASS];
-	VipsRect s;
-
-#ifdef DEBUG_PIXELS
-	printf( "vips_reducev_vector_gen: generating %d x %d at %d x %d\n",
-		r->width, r->height, r->left, r->top ); 
-#endif /*DEBUG_PIXELS*/
-
-	s.left = r->left;
-	s.top = r->top * reducev->vshrink - reducev->voffset;
-	s.width = r->width;
-	s.height = r->height * reducev->vshrink + reducev->n_point;
-	if( vips_region_prepare( ir, &s ) )
-		return( -1 );
-
-#ifdef DEBUG_PIXELS
-	printf( "vips_reducev_vector_gen: preparing %d x %d at %d x %d\n",
-		s.width, s.height, s.left, s.top ); 
-#endif /*DEBUG_PIXELS*/
-
-	for( int i = 0; i < reducev->n_pass; i++ ) 
-		vips_executor_set_program( &executor[i], 
-			reducev->pass[i].vector, ne );
-
-	VIPS_GATE_START( "vips_reducev_vector_gen: work" ); 
-
-	double Y = (r->top + 0.5) * reducev->vshrink - 0.5 - 
-		reducev->voffset;
-
-	for( int y = 0; y < r->height; y++ ) { 
-		VipsPel *q = 
-			VIPS_REGION_ADDR( out_region, r->left, r->top + y );
-		const int py = (int) Y;
-		const int sy = Y * VIPS_TRANSFORM_SCALE * 2;
-		const int siy = sy & (VIPS_TRANSFORM_SCALE * 2 - 1);
-		const int ty = (siy + 1) >> 1;
-		const int *cyo = reducev->matrixo[ty];
-
-#ifdef DEBUG_PIXELS
-		printf( "starting row %d\n", y + r->top ); 
-		printf( "coefficients:\n" );
-		for( int i = 0; i < reducev->n_point; i++ ) 
-			printf( "\t%d - %d\n", i, cyo[i] );
-		printf( "first column of pixel values:\n" ); 
-		for( int i = 0; i < reducev->n_point; i++ ) 
-			printf( "\t%d - %d\n", i, 
-				*VIPS_REGION_ADDR( ir, r->left, py ) ); 
-#endif /*DEBUG_PIXELS*/
-
-		/* We run our n passes to generate this scanline.
-		 */
-		for( int i = 0; i < reducev->n_pass; i++ ) {
-			Pass *pass = &reducev->pass[i]; 
-
-			vips_executor_set_scanline( &executor[i], 
-				ir, r->left, py );
-			vips_executor_set_array( &executor[i],
-				pass->r, seq->t1 );
-			vips_executor_set_array( &executor[i],
-				pass->d2, seq->t2 );
-			for( int j = 0; j < pass->n_param; j++ ) 
-				vips_executor_set_parameter( &executor[i],
-					pass->p[j], cyo[j + pass->first] ); 
-			vips_executor_set_destination( &executor[i], q );
-			vips_executor_run( &executor[i] );
-
-			VIPS_SWAP( signed short *, seq->t1, seq->t2 );
-		}
-
-#ifdef DEBUG_PIXELS
-		printf( "pixel result:\n" );
-		printf( "\t%d\n", *q ); 
-#endif /*DEBUG_PIXELS*/
-
-		Y += reducev->vshrink;
-	}
-
-	VIPS_GATE_STOP( "vips_reducev_vector_gen: work" ); 
-
-	VIPS_COUNT_PIXELS( out_region, "vips_reducev_vector_gen" ); 
-
-	return( 0 );
-}
-
-static int
-vips_reducev_raw( VipsReducev *reducev, VipsImage *in, int height, 
-		VipsImage **out ) 
-{
-	VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS( reducev );
-
-	VipsGenerateFn generate;
-
-	/* We need an 2.6 version if we will use the vector path.
-	 */
-	if( in->BandFmt == VIPS_FORMAT_UCHAR &&
-		vips_vector_isenabled() ) 
-		for( int y = 0; y < VIPS_TRANSFORM_SCALE + 1; y++ ) {
-			reducev->matrixo[y] = 
-				VIPS_ARRAY( NULL, reducev->n_point, int ); 
-			if( !reducev->matrixo[y] )
-				return( -1 ); 
-
-			vips_vector_to_fixed_point( 
-				reducev->matrixf[y], reducev->matrixo[y], 
-				reducev->n_point, 64 );
-		}
-
-	/* Try to build a vector version, if we can.
-	 */
-	generate = vips_reducev_gen;
-	if( in->BandFmt == VIPS_FORMAT_UCHAR &&
-		vips_vector_isenabled() &&
-		!vips_reducev_compile( reducev ) ) {
-		g_info( "reducev: using vector path" ); 
-		generate = vips_reducev_vector_gen;
-	}
-
-	*out = vips_image_new();
-	if( vips_image_pipelinev( *out, 
-		VIPS_DEMAND_STYLE_THINSTRIP, in, (void *) NULL ) )
-		return( -1 );
-
-	/* Don't change xres/yres, leave that to the application layer. For
-	 * example, vipsthumbnail knows the true reduce factor (including the
-	 * fractional part), we just see the integer part here.
-	 */
-	(*out)->Ysize = height;
-	if( (*out)->Ysize <= 0 ) { 
-		vips_error( object_class->nickname, 
-			"%s", _( "image has shrunk to nothing" ) );
-		return( -1 );
-	}
-
-#ifdef DEBUG
-	printf( "vips_reducev_build: reducing %d x %d image to %d x %d\n", 
-		in->Xsize, in->Ysize, 
-		(*out)->Xsize, (*out)->Ysize );  
-#endif /*DEBUG*/
-
-	if( vips_image_generate( *out,
-		vips_reducev_start, generate, vips_reducev_stop, 
-		in, reducev ) )
-		return( -1 );
-
-	vips_reorder_margin_hint( *out, reducev->n_point ); 
-
-	return( 0 );
-}
-
 static int
 vips_reducev_build( VipsObject *object )
 {
 	VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS( object );
 	VipsResample *resample = VIPS_RESAMPLE( object );
 	VipsReducev *reducev = (VipsReducev *) object;
-	VipsImage **t = (VipsImage **) vips_object_local_array( object, 5 );
+	VipsImage **t = (VipsImage **) 
+		vips_object_local_array( object, 5 );
 
 	VipsImage *in;
 	int height;
@@ -885,9 +442,9 @@ vips_reducev_build( VipsObject *object )
 	 */
 	for( int y = 0; y < VIPS_TRANSFORM_SCALE + 1; y++ ) {
 		reducev->matrixf[y] = 
-			VIPS_ARRAY( NULL, reducev->n_point, double ); 
+			VIPS_ARRAY( object, reducev->n_point, double ); 
 		reducev->matrixi[y] = 
-			VIPS_ARRAY( NULL, reducev->n_point, int ); 
+			VIPS_ARRAY( object, reducev->n_point, int ); 
 		if( !reducev->matrixf[y] ||
 			!reducev->matrixi[y] )
 			return( -1 ); 
@@ -924,10 +481,40 @@ vips_reducev_build( VipsObject *object )
 		return( -1 );
 	in = t[2];
 
-	if( vips_reducev_raw( reducev, in, height, &t[3] ) )
+	t[3] = vips_image_new();
+	if( vips_image_pipelinev( t[3], 
+		VIPS_DEMAND_STYLE_THINSTRIP, in, (void *) NULL ) )
 		return( -1 );
+
+	/* Size output. We need to always round to nearest, so round(), not
+	 * rint().
+	 *
+	 * Don't change xres/yres, leave that to the application layer. For
+	 * example, vipsthumbnail knows the true reduce factor (including the
+	 * fractional part), we just see the integer part here.
+	 */
+	t[3]->Ysize = height;
+	if( t[3]->Ysize <= 0 ) { 
+		vips_error( object_class->nickname, 
+			"%s", _( "image has shrunk to nothing" ) );
+		return( -1 );
+	}
+
+#ifdef DEBUG
+	printf( "vips_reducev_build: reducing %d x %d image to %d x %d\n", 
+		in->Xsize, in->Ysize, 
+		t[3]->Xsize, t[3]->Ysize );
+#endif /*DEBUG*/
+
+	if( vips_image_generate( t[3],
+		vips_start_one, vips_reducev_gen, vips_stop_one, 
+		in, reducev ) )
+		return( -1 );
+
 	in = t[3];
 
+	vips_reorder_margin_hint( in, reducev->n_point );
+
 	/* Large reducev will throw off sequential mode. Suppose thread1 is
 	 * generating tile (0, 0), but stalls. thread2 generates tile
 	 * (0, 1), 128 lines further down the output. After it has done,
@@ -938,7 +525,7 @@ vips_reducev_build( VipsObject *object )
 	 * always have the previous XX lines of the shrunk image, and we won't
 	 * fetch out of order. 
 	 */
-	if( vips_image_get_typeof( in, VIPS_META_SEQUENTIAL ) ) { 
+	if( vips_image_is_sequential( in ) ) { 
 		g_info( "reducev sequential line cache" ); 
 
 		if( vips_sequential( in, &t[4], 
@@ -965,7 +552,6 @@ vips_reducev_class_init( VipsReducevClass *reducev_class )
 
 	VIPS_DEBUG_MSG( "vips_reducev_class_init\n" );
 
-	gobject_class->finalize = vips_reducev_finalize;
 	gobject_class->set_property = vips_object_set_property;
 	gobject_class->get_property = vips_object_get_property;
 
diff --git a/meson.build b/meson.build
index 1111111..2222222 100644
--- a/meson.build
+++ b/meson.build
@@ -413,21 +413,6 @@ if libopenjp2_dep.found()
     cfg_var.set('HAVE_LIBOPENJP2', '1')
 endif
 
-# we use loadpw etc.
-orc_dep = dependency('orc-0.4', version: '>=0.4.11', required: get_option('orc'))
-if orc_dep.found()
-    libvips_deps += orc_dep
-    cfg_var.set('HAVE_ORC', '1')
-    # orc 0.4.30+ works with cf-protection, but 0.4.30 has a bug with multiple
-    # definitions of OrcTargetPowerPCFlags, so insist on 0.4.31
-    if orc_dep.version().version_compare('>=0.4.31')
-        cfg_var.set('HAVE_ORC_CF_PROTECTION', '1')
-    endif
-    if cc.has_function('orc_program_get_error', prefix: '#include <orc/orc.h>', dependencies: orc_dep)
-        cfg_var.set('HAVE_ORC_PROGRAM_GET_ERROR', '1')
-    endif
-endif
-
 # pick 4200 as the starting version number ... no reason, really, it'd
 # probably work with much older versions
 pdfium_dep = dependency('pdfium', version: '>=4200', required: get_option('pdfium'))
@@ -643,7 +628,6 @@ build_summary = {
     },
   'Optional external packages':
     {'use fftw for FFTs': [fftw_dep.found()],
-     'accelerate loops with ORC': [orc_dep.found()],
      'ICC profile support with lcms': [lcms_dep.found()],
      'zlib': [zlib_dep.found()],
      'text rendering with pangocairo': [pangocairo_dep.found()],
diff --git a/meson_options.txt b/meson_options.txt
index 1111111..2222222 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -153,11 +153,6 @@ option('openslide-module',
   value: 'auto',
   description: 'Build OpenSlide as module')
 
-option('orc',
-  type: 'feature',
-  value: 'auto',
-  description: 'Build with orc-0.4')
-
 option('pangocairo',
   type: 'feature',
   value: 'auto',
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 1111111..2222222 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -46,7 +46,6 @@ libvips/include/vips/threadpool.h
 libvips/include/vips/transform.h
 libvips/include/vips/type.h
 libvips/include/vips/util.h
-libvips/include/vips/vector.h
 libvips/include/vips/video.h
 libvips/include/vips/vips7compat.h
 libvips/include/vips/vips.h
@@ -345,7 +344,6 @@ libvips/iofuncs/targetcustom.c
 libvips/iofuncs/threadpool.c
 libvips/iofuncs/type.c
 libvips/iofuncs/util.c
-libvips/iofuncs/vector.c
 libvips/iofuncs/vips.c
 libvips/iofuncs/vipsmarshal.c
 libvips/iofuncs/window.c
